{"version":3,"sources":["visualiser/cell.jsx","visualiser/legend.jsx","visualiser/visualiser.jsx","App.js","index.js"],"names":["Cell","this","props","col","row","isFinish","isStart","isWall","isPath","isVisited","cName","className","id","React","Component","Legend","pathFound","Visualiser","generateMaze","grid","setState","findPath","state","startCell","endCell","visitedCellsInOrder","dijkstra","animateDijkstra","i","length","setTimeout","animatePath","document","getElementById","temp","path","push","previousCell","makeGrid","onClick","map","rowId","key","cell","cellId","finishCell","distance","unVisitedCells","getCells","sort","nodeA","nodeB","closestCell","shift","Infinity","updateUnvisitedNeighbors","unvisitedNeighbors","getNeighbors","filter","neighbor","neighbors","listOfCells","j","trace","walls","getFrontiers","randWallId","randomInt","randWall","splice","includes","randNeighbor","chosenCell","getCellBetween","newFrontiers","wall","cellOne","cellTwo","rowOne","colOne","rowTwo","colTwo","max","a","b","frontiers","min","Math","floor","random","curCol","makeCell","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.77dd2e75.chunk.js","sourcesContent":["import React from 'react';\r\nimport './cell.css';\r\n\r\nexport default class Cell extends React.Component {\r\n    \r\n    render()\r\n    {\r\n        const {\r\n            col,\r\n            row,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            isPath,\r\n            isVisited,\r\n        } = this.props;\r\n\r\n        let cName = \"cell\"\r\n        if(isWall)\r\n            cName += \" wall\"\r\n        else{\r\n            if(isVisited)\r\n                cName += \" visited\"\r\n            else{\r\n                if(isPath)\r\n                    cName += \" path\"\r\n                else{\r\n                    if (isFinish)\r\n                        cName += \" finish\"\r\n                    else if (isStart)\r\n                        cName += \" start\"\r\n                }\r\n            }\r\n        }   \r\n            \r\n        return (\r\n            <div\r\n                className = {cName}\r\n                id = {`${row}-${col}`}\r\n            ></div>\r\n        );\r\n    }\r\n\r\n}","import React from 'react';\r\nimport './legend.css';\r\n\r\nexport default class Legend extends React.Component {\r\n    \r\n    render()\r\n    {  \r\n            \r\n        return (\r\n            <div\r\n                className = \"legend\"\r\n            >\r\n                <ul>\r\n                    <li>\r\n                        <div className=\"legendCell path\"></div>\r\n                        <h6>Path</h6>\r\n                    </li>\r\n                    <li>\r\n                        <div className=\"legendCell wall\"></div>\r\n                        <h6>Wall</h6>\r\n                    </li>\r\n                    <li>\r\n                        <div className=\"legendCell visited\"></div>\r\n                        <h6>Visited</h6>\r\n                    </li>\r\n                    <li>\r\n                        <div className=\"legendCell start\"></div>\r\n                        <h6>Start</h6>\r\n                    </li>\r\n                    <li>\r\n                        <div className=\"legendCell finish\"></div>\r\n                        <h6>Finish</h6>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        );\r\n    }\r\n\r\n}","import React from 'react';\r\nimport './visualiser.css';\r\nimport Cell from './cell'\r\nimport Legend from './legend'\r\n\r\nconst numRow = 20;\r\nconst numCol = 50;\r\nlet pathFound = false;\r\n\r\nlet startRow = 10\r\nlet startCol = 10\r\nlet endRow = 10\r\nlet endCol = 40\r\n\r\n\r\n\r\nclass Visualiser extends React.Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n          grid: [],\r\n        };\r\n    }\r\n\r\n    generateMaze = () => {\r\n        const grid = generateMaze();\r\n        this.setState({\r\n            grid:grid,\r\n        })\r\n        pathFound = false;\r\n    }\r\n\r\n    findPath = () => {\r\n        const {grid} = this.state;\r\n        if(pathFound){\r\n            return\r\n        }\r\n        const startCell = grid[startRow][startCol];\r\n        const endCell = grid[endRow][endCol]\r\n\r\n        const visitedCellsInOrder = dijkstra(grid,startCell,endCell);\r\n        this.animateDijkstra(visitedCellsInOrder)\r\n        pathFound = true;\r\n    }\r\n\r\n    //DIJKSTRA ANIMATIONS\r\n    animateDijkstra = (visitedCellsInOrder) => {\r\n        const {grid} = this.state;\r\n\r\n        for(let i = 0; i < visitedCellsInOrder.length; i++){\r\n            if (i === visitedCellsInOrder.length-1) {\r\n                setTimeout(() => {\r\n                  this.animatePath();\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            const row = visitedCellsInOrder[i].row;\r\n            const col = visitedCellsInOrder[i].col;\r\n            if((row === startRow && col === startCol) || (row === endRow && col === endCol))\r\n                continue\r\n            setTimeout(() => {\r\n                grid[row][col].isVisited = true;\r\n                document.getElementById(`${row}-${col}`).className = 'cell visited'\r\n            },10*i)\r\n        }\r\n\r\n    }\r\n    animatePath = () => {\r\n        const {grid} = this.state;\r\n        const lastCell = grid[endRow][endCol];\r\n        let temp = lastCell\r\n\r\n        //shortest path\r\n        const path = [];\r\n        while(temp !== null){\r\n            path.push(temp);\r\n            temp = temp.previousCell\r\n        }\r\n\r\n        for(let i = 0; i < path.length; i++){\r\n            let row = path[i].row;\r\n            let col = path[i].col;\r\n            if ((row === startRow && col === startCol) || (row === endRow && col === endCol))\r\n                continue;\r\n            setTimeout(() => {\r\n                grid[row][col].isPath = true;\r\n                document.getElementById(`${row}-${col}`).className = \"cell path\";\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = makeGrid()\r\n        this.setState({\r\n            grid: grid\r\n        })\r\n    }\r\n\r\n\r\n    render(){\r\n        const grid = this.state.grid;\r\n        return (\r\n            <main>\r\n                <Legend/>\r\n                <h1>Dijkstra algorithm visualisation</h1>\r\n                <div className=\"menu\">\r\n                    <button onClick={this.findPath}>Find Path</button>\r\n                    <button onClick={this.generateMaze}>Generate Maze</button>\r\n                    {/* <button onClick={this.reset}>Reset</button> */}\r\n                </div>\r\n                <div className=\"grid\" id=\"grid\">\r\n                    {grid.map((row,rowId) => {\r\n                        return (\r\n                            <div key={rowId} className = \"row\">\r\n                                {row.map((cell,cellId) => {\r\n                                    const {row,col,isStart,isFinish,isWall,isVisited,isPath} = cell\r\n                                    return (\r\n                                        <Cell\r\n                                            key={cellId}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            isVisited = {isVisited}\r\n                                            isPath = {isPath}\r\n                                        ></Cell>\r\n                                    )\r\n                                })}\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </main>\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n// ********************* //\r\n//      DIJKSTRA         //\r\n// ********************* //\r\n\r\nconst dijkstra = (grid,startCell,finishCell) => {\r\n    const visitedCellsInOrder = [];\r\n    startCell.distance = 0;\r\n    const unVisitedCells = getCells(grid);\r\n    while(unVisitedCells.length){\r\n        unVisitedCells.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); // min heap better option\r\n        const closestCell = unVisitedCells.shift();\r\n        if(closestCell.isWall) continue;\r\n        if(closestCell.distance === Infinity) return visitedCellsInOrder\r\n        closestCell.isVisited = true;\r\n        visitedCellsInOrder.push(closestCell);\r\n        if(closestCell === finishCell) return visitedCellsInOrder\r\n        updateUnvisitedNeighbors(closestCell, grid);\r\n    }\r\n}\r\n\r\nconst updateUnvisitedNeighbors = (cell, grid) => {\r\n    const unvisitedNeighbors = getNeighbors(cell, grid).filter(neighbor => !neighbor.isVisited);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = cell.distance + 1;\r\n      neighbor.previousCell = cell;\r\n    }\r\n}\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n    const neighbors = [];\r\n    const {col,row} = cell;\r\n\r\n    if(col - 1 >= 0)     neighbors.push(grid[row][col-1])     //left\r\n    if(col + 1 < numCol) neighbors.push(grid[row][col+1])     //right\r\n    if(row + 1 < numRow) neighbors.push(grid[row+1][col])     //top\r\n    if(row - 1 >= 0)     neighbors.push(grid[row-1][col])     //bottom\r\n\r\n    return neighbors;\r\n}\r\n\r\nconst getCells = (grid) => {\r\n    const listOfCells = [];\r\n    for(let i = 0; i < numRow; i++){\r\n        for(let j = 0; j < numCol; j++){\r\n            listOfCells.push(grid[i][j]);\r\n        }\r\n    }\r\n    return listOfCells;\r\n}\r\n\r\n\r\n// ********************* //\r\n//      PRIM MAZE        //\r\n// ********************* //\r\nconst generateMaze = () => {\r\n    const grid = makeGrid();\r\n    for(let i = 0; i < numRow; i++){\r\n        for(let j = 0; j < numCol; j++){\r\n            grid[i][j].isWall = true;\r\n            grid[i][j].isVisited = false;\r\n            grid[i][j].isPath = false;\r\n        }\r\n    }\r\n\r\n    const startCell = grid[startRow][startCol];\r\n\r\n    const trace = [];\r\n    trace.push(startCell)\r\n\r\n    const walls = getFrontiers(startCell,grid)\r\n\r\n    while(walls.length > 0){\r\n        const randWallId = randomInt(0,walls.length-1);\r\n        const randWall = walls.splice(randWallId,1)[0];\r\n\r\n        const neighbors = getFrontiers(randWall,grid).filter(neighbor => trace.includes(neighbor));\r\n        if(neighbors.length > 0){\r\n            const randNeighbor = neighbors[randomInt(0,neighbors.length-1)];\r\n            const chosenCell = getCellBetween(randNeighbor,randWall,grid);\r\n            trace.push(chosenCell);\r\n            trace.push(randWall);\r\n            chosenCell.isWall = false;\r\n            randWall.isWall = false;\r\n        }\r\n        const newFrontiers = getFrontiers(randWall,grid).filter(wall => wall.isWall);\r\n        for(let i = 0; i < newFrontiers.length; i++){\r\n            if(!walls.includes(newFrontiers[i])){\r\n                walls.push(newFrontiers[i])\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    for(let i = 0; i < trace.length; i++){\r\n        const row = trace[i].row;\r\n        const col = trace[i].col;\r\n        if (row === startRow && col === startCol){\r\n            document.getElementById(`${row}-${col}`).className = \"cell start\"\r\n            continue\r\n        }\r\n            \r\n        if(row === endRow && col === endCol){\r\n            document.getElementById(`${row}-${col}`).className = \"cell finish\"\r\n            continue\r\n        }\r\n        grid[row][col].isWall = false;\r\n        document.getElementById(`${row}-${col}`).className = \"cell\"\r\n    }\r\n\r\n    for(let i = 0; i < numCol; i++){\r\n        grid[0][i].isWall = true;\r\n        const row = grid[0][i].row;\r\n        const col = grid[0][i].col;\r\n        document.getElementById(`${row}-${col}`).className = \"cell wall\"\r\n    }\r\n    for(let i = 0; i < numRow; i++){\r\n        grid[i][0].isWall = true;\r\n        const row = grid[i][0].row;\r\n        const col = grid[i][0].col;\r\n        document.getElementById(`${row}-${col}`).className = \"cell wall\"\r\n    }\r\n    return grid;\r\n\r\n}\r\n\r\nconst getCellBetween = (cellOne, cellTwo, grid) => {\r\n    const rowOne = cellOne.row\r\n    const colOne = cellOne.col\r\n    const rowTwo = cellTwo.row\r\n    const colTwo = cellTwo.col\r\n    if(rowOne === rowTwo)\r\n        return grid[rowOne][max(colOne,colTwo)-1]\r\n    else if (colOne === colTwo)\r\n        return grid[max(rowOne,rowTwo)-1][colOne]\r\n}\r\n\r\nfunction max(a,b){\r\n    if(a >= b) return a;\r\n    else return b;\r\n}\r\n\r\nconst getFrontiers = (cell, grid) => {\r\n    const frontiers = [];\r\n    const col = cell.col;\r\n    const row = cell.row;\r\n\r\n    if(col - 2 >= 0) frontiers.push(grid[row][col-2])        //left\r\n    if(col + 2 < numCol) frontiers.push(grid[row][col+2])    //right\r\n    if(row + 2 < numRow) frontiers.push(grid[row+2][col])    //top\r\n    if(row - 2 >= 0) frontiers.push(grid[row-2][col])        //bottom\r\n\r\n    return frontiers;\r\n\r\n}\r\n\r\nfunction randomInt(min, max) {\r\n\treturn min + Math.floor((max - min) * Math.random());\r\n}\r\n\r\n// GRID //\r\n\r\nconst makeGrid = () => {\r\n    const grid = [];\r\n    for(let i = 0; i < numRow; i++){\r\n        const curCol = []\r\n        for(let j = 0; j < numCol; j++){\r\n            curCol.push(makeCell(i,j))\r\n        }\r\n        grid.push(curCol)\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst makeCell = (row,col) => {\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isStart: row === startRow && col === startCol,\r\n        isFinish: row === endRow && col === endCol,\r\n        isWall: false,\r\n        previousCell: null,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isPath: false,\r\n    }\r\n}\r\n\r\nconst copyGrid = (grid) => {\r\n    const newGrid = makeGrid();\r\n\r\n    for(let i = 0; i < numRow; i++){\r\n        for(let j = 0; j < numCol; j++){\r\n            newGrid[i][j].row = grid[i][j].row;\r\n            newGrid[i][j].col = grid[i][j].col;\r\n            newGrid[i][j].isStart = grid[i][j].isStart;\r\n            newGrid[i][j].isFinish = grid[i][j].isFinish;\r\n            newGrid[i][j].isWall = grid[i][j].isWall;\r\n            newGrid[i][j].previousCell = grid[i][j].previousCell;\r\n            newGrid[i][j].distance = grid[i][j].distance;\r\n            newGrid[i][j].isVisited = grid[i][j].isVisited;\r\n        }\r\n    }\r\n    return newGrid\r\n}\r\n\r\n\r\nexport default Visualiser;\r\n","import React from 'react';\nimport Visualiser from './visualiser/visualiser.jsx'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Visualiser/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}