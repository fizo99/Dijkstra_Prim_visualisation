{"version":3,"sources":["visualiser/components/cell.jsx","visualiser/components/legend.jsx","visualiser/algorithms/dijkstra.js","visualiser/algorithms/astar.js","visualiser/components/visualiser.jsx","index.js"],"names":["Cell","this","props","col","row","isFinish","isStart","isWall","isPath","cName","isVisited","className","id","React","Component","Legend","dijkstra","grid","startCell","finishCell","visitedCellsInOrder","distance","unVisitedCells","getCells","length","sort","nodeA","nodeB","closestCell","shift","Infinity","push","updateUnvisitedNeighbors","cell","unvisitedNeighbors","getNeighbors","filter","neighbor","previousCell","numCol","numRow","neighbors","listOfCells","i","j","astar","openSet","closedSet","visitedInOrder","lowestIndex","f","current","removeFromArray","includes","tempG","g","h","heuristic","a","b","Math","abs","arr","element","splice","Visualiser","makeCell","state","startCellCoords","endCellCoords","makeGrid","curCol","resetGrid","setState","drawingWalls","mouseClicked","changingStart","changingEnd","aStarSolve","endCell","animate","then","data","delay","newGrid","animatePath","dijkstraSolve","animationSpeed","Promise","resolve","reject","setTimeout","document","getElementById","temp","path","ms","res","handleAnimationSpeed","e","target","value","changeStartHandler","changeEndHandler","changeEndCell","cellCoords","split","parseInt","changeStartCell","handlePress","coords","tempGrid","handleMouseDown","handleMouseUp","visitedCells","clickOption","onClick","onChange","defaultValue","hidden","disabled","onMouseMove","onMouseDown","onMouseUp","chooseFunction","map","rowId","key","cellId","handleClick","handleMousePress","href","changeEndFunc","changeStartFunc","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.887a2183.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./styles/cell.css\";\r\n\r\nexport default class Cell extends React.Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      isPath,\r\n      isVisited,\r\n      //distance\r\n    } = this.props;\r\n\r\n    let cName = \"cell\";\r\n\r\n    if (isVisited) cName = \"cell visited\";\r\n    if (isPath) cName = \"cell path\";\r\n    if (isFinish) cName = \"cell finish\";\r\n    if (isStart) cName = \"cell start\";\r\n    if (isWall) cName = \"cell wall\";\r\n\r\n    return (\r\n      <div className={cName} id={`${row}-${col}`}>\r\n        {isStart ? <i className=\"far fa-play-circle\"></i> : null}\r\n        {isFinish ? <i className=\"far fa-times-circle\"></i> : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport \"./styles/legend.css\";\r\n\r\nexport default class Legend extends React.Component {\r\n  render() {\r\n    return (\r\n      <section className=\"legend\">\r\n        <ul>\r\n          <li>\r\n            <div className=\"legendCell path\"></div>\r\n            <h6>Path</h6>\r\n          </li>\r\n          <li>\r\n            <div className=\"legendCell wall\"></div>\r\n            <h6>Wall</h6>\r\n          </li>\r\n          <li>\r\n            <div className=\"legendCell visited\"></div>\r\n            <h6>Visited</h6>\r\n          </li>\r\n          <li>\r\n            <div className=\"legendCell start\"></div>\r\n            <h6>Start</h6>\r\n          </li>\r\n          <li>\r\n            <div className=\"legendCell finish\"></div>\r\n            <h6>Finish</h6>\r\n          </li>\r\n        </ul>\r\n      </section>\r\n    );\r\n  }\r\n}\r\n","export const dijkstra = (grid, startCell, finishCell) => {\r\n  const visitedCellsInOrder = [];\r\n  startCell.distance = 0;\r\n  const unVisitedCells = getCells(grid);\r\n  while (unVisitedCells.length) {\r\n    unVisitedCells.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); // min heap better option\r\n    const closestCell = unVisitedCells.shift();\r\n    if (closestCell.isWall) continue;\r\n    if (closestCell.distance === Infinity) return visitedCellsInOrder;\r\n    closestCell.isVisited = true;\r\n    visitedCellsInOrder.push(closestCell);\r\n    if (closestCell === finishCell) return visitedCellsInOrder;\r\n    updateUnvisitedNeighbors(closestCell, grid);\r\n  }\r\n};\r\n\r\nconst updateUnvisitedNeighbors = (cell, grid) => {\r\n  const unvisitedNeighbors = getNeighbors(cell, grid).filter(\r\n    (neighbor) => !neighbor.isVisited\r\n  );\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = cell.distance + 1;\r\n    neighbor.previousCell = cell;\r\n  }\r\n};\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n  const neighbors = [];\r\n  const { col, row } = cell;\r\n\r\n  if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n  if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n  if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n  if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n\r\n  return neighbors;\r\n};\r\n\r\nconst getCells = (grid) => {\r\n  const listOfCells = [];\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n\r\n  for (let i = 0; i < numRow; i++) {\r\n    for (let j = 0; j < numCol; j++) {\r\n      listOfCells.push(grid[i][j]);\r\n    }\r\n  }\r\n  return listOfCells;\r\n};\r\n","export const astar = (grid, startCell, finishCell) => {\r\n    const openSet = [];     \r\n    const closedSet = [];   \r\n    openSet.push(grid[startCell.row][startCell.col])\r\n    const visitedInOrder = [];\r\n\r\n    while(openSet.length > 0){\r\n        let lowestIndex = 0;\r\n        for(let i = 0; i < openSet.length; i++){\r\n            if(openSet[i].f < openSet[lowestIndex].f){\r\n                lowestIndex = i;\r\n            }\r\n        }\r\n        \r\n        if(openSet[lowestIndex] === finishCell){\r\n            //return path(finishCell);\r\n            return visitedInOrder;\r\n        }\r\n        \r\n        const current = openSet[lowestIndex]\r\n        visitedInOrder.push(current)\r\n\r\n        removeFromArray(openSet,current) //spllice(lowestIndex,1) ??\r\n        closedSet.push(current)\r\n        //grid[current.row][current.col].isVisited = true;\r\n\r\n        const neighbors = getNeighbors(current,grid);\r\n        for(let i = 0; i < neighbors.length; i++){\r\n            let neighbor = neighbors[i];\r\n            if(neighbor.isWall){\r\n                closedSet.push(neighbor)\r\n                continue;\r\n            }\r\n            visitedInOrder.push(neighbor)\r\n            if(!closedSet.includes(neighbor)){\r\n                //grid[neighbor.row][neighbor.col].g = grid[current.row][current.col].g + 1\r\n                let tempG = grid[current.row][current.col].g + 1\r\n                if(openSet.includes(neighbor)){\r\n                    if(tempG < neighbor.g){\r\n                        neighbor.g = tempG;\r\n                    }\r\n                }else{\r\n                    neighbor.g = tempG;\r\n                    openSet.push(neighbor);\r\n                }\r\n\r\n                neighbor.h = heuristic(neighbor,finishCell)\r\n                neighbor.f = neighbor.g + neighbor.h\r\n                neighbor.previousCell = current;\r\n            }\r\n            \r\n        }\r\n    }\r\n    return visitedInOrder;\r\n    //return grid;\r\n    // const path = [];\r\n    // let end = finishCell\r\n    // while(end.previousCell !== startCell){\r\n    //     path.push(end)\r\n    //     end = end.previousCell\r\n    // }\r\n    // return path;\r\n\r\n\r\n};\r\n\r\n// const path = (endCell) => {\r\n//     const path = [];\r\n//     while(endCell.previousCell != null){\r\n//         path.push(endCell)\r\n//         endCell = endCell.previousCell;\r\n//     }\r\n//     return path;\r\n// }\r\n\r\nconst heuristic = (a,b) => {\r\n    if(a.row === b.row) return Math.abs(a.col-b.col)\r\n    if(a.col === b.col) return Math.abs(a.row-b.row)\r\n    return Math.abs(a.row-b.row) + Math.abs(a.col-b.col)\r\n    //pythagoras a^2 + b^2 = c^2\r\n    //return Math.sqrt(Math.abs(a.col-b.col)+Math.abs(a.row-b.row))\r\n}\r\n  \r\nconst removeFromArray = (arr,element) => {\r\n    for(let i = arr.length-1; i >=0; i--){\r\n        if(arr[i]===element){\r\n            arr.splice(i,1);\r\n        }\r\n    }\r\n}\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n    const numCol = grid[0].length;\r\n    const numRow = grid.length;\r\n    const neighbors = [];\r\n    const { col, row } = cell;\r\n  \r\n    if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n    if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n    if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n    if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n  \r\n    return neighbors;\r\n  };\r\n  ","import React from \"react\";\r\nimport \"./styles/visualiser.css\";\r\nimport Cell from \"./cell\";\r\nimport Legend from \"./legend\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { astar } from \"../algorithms/astar\";\r\n\r\nconst numRow = 20;\r\nconst numCol = 50;\r\n\r\nclass Visualiser extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      visitedCells: [],\r\n      startCellCoords: {\r\n        row: 10,\r\n        col: 10,\r\n      },\r\n      endCellCoords: {\r\n        row: 10,\r\n        col: 40,\r\n      },\r\n      clickOption: \"\",\r\n      drawingWalls: false,\r\n      mouseClicked: false,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n      animationSpeed: 7,\r\n    };\r\n    this.tempGrid = null;\r\n  }\r\n\r\n  makeCell = (row, col) => {\r\n    const { startCellCoords, endCellCoords } = this.state;\r\n    return {\r\n      row: row,\r\n      col: col,\r\n      isStart: row === startCellCoords.row && col === startCellCoords.col,\r\n      isFinish: row === endCellCoords.row && col === endCellCoords.col,\r\n      isWall: false,\r\n      previousCell: null,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isPath: false,\r\n      g: 0,\r\n      f: 0,\r\n      h: 0,\r\n    };\r\n  };\r\n  makeGrid = () => {\r\n    const grid = [];\r\n    for (let i = 0; i < numRow; i++) {\r\n      const curCol = [];\r\n      for (let j = 0; j < numCol; j++) {\r\n        curCol.push(this.makeCell(i, j));\r\n      }\r\n      grid.push(curCol);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  resetGrid = () => {\r\n    const { grid } = this.state;\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].isPath = false;\r\n        grid[j][i].isWall = false;\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: grid,\r\n      drawingWalls: false,\r\n      mouseClicked: false,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n    });\r\n  };\r\n\r\n  //ALGORITHMS\r\n  aStarSolve = async () => {\r\n    const { startCellCoords, endCellCoords, grid } = this.state;\r\n    const startCell = grid[startCellCoords.row][startCellCoords.col];\r\n    const endCell = grid[endCellCoords.row][endCellCoords.col];\r\n\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].isPath = false;\r\n      }\r\n    }\r\n    await this.setState({\r\n      grid: grid,\r\n    });\r\n\r\n    const visitedCellsInOrder = astar(grid, startCell, endCell);\r\n\r\n    const result = this.animate(visitedCellsInOrder);\r\n    result\r\n      .then(async (data) => {\r\n        await this.delay(data[1]);\r\n        return data[0];\r\n      })\r\n      .then((grid) => {\r\n        const newGrid = this.animatePath(grid);\r\n        this.setState({ grid: newGrid });\r\n      });\r\n  };\r\n\r\n  dijkstraSolve = async () => {\r\n    const { grid, startCellCoords, endCellCoords } = this.state;\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].isPath = false;\r\n      }\r\n    }\r\n    await this.setState({\r\n      grid: grid,\r\n    });\r\n    const startCell = grid[startCellCoords.row][startCellCoords.col];\r\n    const endCell = grid[endCellCoords.row][endCellCoords.col];\r\n\r\n    const visitedCellsInOrder = dijkstra(grid, startCell, endCell);\r\n\r\n    const result = this.animate(visitedCellsInOrder);\r\n    result\r\n      .then(async (data) => {\r\n        await this.delay(data[1]);\r\n        return data[0];\r\n      })\r\n      .then((grid) => {\r\n        const newGrid = this.animatePath(grid);\r\n        this.setState({ grid: newGrid });\r\n      });\r\n  };\r\n\r\n  //ANIMATIONS\r\n  animate = (visitedCellsInOrder) => {\r\n    const { grid, endCellCoords, startCellCoords, animationSpeed } = this.state;\r\n    return new Promise(function (resolve, reject) {\r\n      for (let i = 1; i < visitedCellsInOrder.length; i++) {\r\n        const row = visitedCellsInOrder[i].row;\r\n        const col = visitedCellsInOrder[i].col;\r\n        if (\r\n          (row === startCellCoords.row && col === startCellCoords.col) ||\r\n          (row === endCellCoords.row && col === endCellCoords.col)\r\n        )\r\n          continue;\r\n        setTimeout(() => {\r\n          grid[row][col].isVisited = true;\r\n          document.getElementById(`${row}-${col}`).className = \"cell visited\";\r\n        }, i * animationSpeed);\r\n      }\r\n      resolve([grid, visitedCellsInOrder.length * animationSpeed]); // immediately give the result: 123\r\n    });\r\n  };\r\n  animatePath = (grid) => {\r\n    const { endCellCoords, startCellCoords } = this.state;\r\n    const lastCell = grid[endCellCoords.row][endCellCoords.col];\r\n    let temp = lastCell;\r\n\r\n    //shortest path\r\n    const path = [];\r\n    while (temp !== null) {\r\n      path.push(temp);\r\n      temp = temp.previousCell;\r\n    }\r\n\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      let row = path[i].row;\r\n      let col = path[i].col;\r\n      if (\r\n        (row === startCellCoords.row && col === startCellCoords.col) ||\r\n        (row === endCellCoords.row && col === endCellCoords.col)\r\n      )\r\n        continue;\r\n      grid[row][col].isPath = true;\r\n      document.getElementById(`${row}-${col}`).className = \"cell path\";\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  delay = (ms) => {\r\n    return new Promise((res) => setTimeout(res, ms));\r\n  };\r\n\r\n  handleAnimationSpeed = (e) => {\r\n    switch (e.target.value) {\r\n      case \"fast\":\r\n        this.setState({ animationSpeed: 2 });\r\n        break;\r\n      case \"average\":\r\n        this.setState({ animationSpeed: 12 });\r\n        break;\r\n      case \"slow\":\r\n        this.setState({ animationSpeed: 25 });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  //START / END BUTTON HANDLERS\r\n  changeStartHandler = () => {\r\n    this.setState({\r\n      changingStart: true,\r\n      changingEnd: false,\r\n      drawingWalls: false,\r\n    });\r\n  };\r\n  changeEndHandler = () => {\r\n    this.setState({\r\n      changingEnd: true,\r\n      changingStart: false,\r\n      drawingWalls: false,\r\n    });\r\n  };\r\n\r\n  //CHANGING START/END CELLS\r\n  changeEndCell = (e) => {\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { endCellCoords, grid } = this.state;\r\n    grid[endCellCoords.row][endCellCoords.col].isFinish = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isFinish = true;\r\n    this.setState({\r\n      grid: grid,\r\n      endCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n  changeStartCell = (e) => {\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { startCellCoords, grid } = this.state;\r\n    grid[startCellCoords.row][startCellCoords.col].isStart = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isStart = true;\r\n    this.setState({\r\n      grid: grid,\r\n      startCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n\r\n  //DRAW WALLS BUTTON HANDLER\r\n  drawingWalls = () => {\r\n    this.setState({\r\n      drawingWalls: true,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n    });\r\n  };\r\n\r\n  //DRAG ON GRID / DRAWING WALLS\r\n  handlePress = (e) => {\r\n    const coords = e.target.id.split(\"-\");\r\n    if (coords.length < 2) return;\r\n    if (\r\n      (parseInt(coords[0]) === this.state.startCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.startCellCoords.col) ||\r\n      (parseInt(coords[0]) === this.state.endCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.endCellCoords.col)\r\n    )\r\n      return;\r\n    document.getElementById(`${coords[0]}-${coords[1]}`).className =\r\n      \"cell wall\";\r\n    this.tempGrid[coords[0]][coords[1]].isWall = true;\r\n  };\r\n  handleMouseDown = () => {\r\n    this.tempGrid = this.state.grid;\r\n    this.setState({\r\n      mouseClicked: true,\r\n    });\r\n  };\r\n  handleMouseUp = () => {\r\n    this.setState({\r\n      mouseClicked: false,\r\n      grid: this.tempGrid,\r\n    });\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = this.makeGrid();\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const grid = this.state.grid;\r\n    const { drawingWalls, mouseClicked } = this.state;\r\n    return (\r\n      <main>\r\n        <section className=\"menu\">\r\n          <Legend />\r\n          <section className=\"buttons\">\r\n            <button onClick={this.dijkstraSolve}>\r\n              <span>Dijkstra</span>\r\n            </button>\r\n            <button onClick={this.aStarSolve}>\r\n              <span>A*</span>\r\n            </button>\r\n          </section>\r\n          <section className=\"interactions\">\r\n            <select\r\n              id=\"animationSpeed\"\r\n              onChange={this.handleAnimationSpeed}\r\n              defaultValue={\"Speed\"}\r\n            >\r\n              <option hidden disabled value=\"Speed\">\r\n                Speed\r\n              </option>\r\n              <option value=\"fast\">Fast</option>\r\n              <option value=\"average\">Average</option>\r\n              <option value=\"slow\">Slow</option>\r\n            </select>\r\n            <button onClick={this.resetGrid} className=\"btn-reset\">\r\n              <span>Reset</span>\r\n            </button>\r\n            <button onClick={this.drawingWalls} className=\"btn-wall\">\r\n              <span>Add walls</span>\r\n            </button>\r\n            <button onClick={this.changeStartHandler} className=\"btn-start\">\r\n              <span>Change Start Cell</span>\r\n            </button>\r\n            <button onClick={this.changeEndHandler} className=\"btn-finish\">\r\n              <span>Change End Cell</span>\r\n            </button>\r\n          </section>\r\n        </section>\r\n        <section\r\n          className=\"grid\"\r\n          id=\"grid\"\r\n          onMouseMove={drawingWalls && mouseClicked ? this.handlePress : null}\r\n          onMouseDown={drawingWalls ? this.handleMouseDown : null}\r\n          onMouseUp={drawingWalls ? this.handleMouseUp : null}\r\n          onClick={chooseFunction(\r\n            this.state,\r\n            this.changeEndCell,\r\n            this.changeStartCell\r\n          )}\r\n        >\r\n          {grid.map((row, rowId) => {\r\n            return (\r\n              <div key={rowId} className=\"row\">\r\n                {row.map((cell, cellId) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    isWall,\r\n                    isVisited,\r\n                    isPath,\r\n                  } = cell;\r\n                  return (\r\n                    <Cell\r\n                      key={cellId}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      isWall={isWall}\r\n                      isVisited={isVisited}\r\n                      isPath={isPath}\r\n                      handleClick={this.handleClick}\r\n                      handleMousePress={this.handleMousePress}\r\n                      handleMouseUp={this.handleMouseUp}\r\n                    ></Cell>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </section>\r\n        <footer>\r\n          <div className=\"socials\">\r\n            <a href=\"https://github.com/fizo99\">\r\n              <i className=\"fab fa-github-square\"></i>\r\n            </a>\r\n            <a href=\"https://www.linkedin.com/in/krzysztof-huczek-a1bb36175/\">\r\n              <i className=\"fab fa-linkedin\"></i>\r\n            </a>\r\n            <a href=\"https://www.facebook.com/mvpett\">\r\n              <i className=\"fab fa-facebook-square\"></i>\r\n            </a>\r\n          </div>\r\n          <h6>© Krzysztof Huczek, 2020</h6>\r\n        </footer>\r\n      </main>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Visualiser;\r\n\r\nfunction chooseFunction(state, changeEndFunc, changeStartFunc) {\r\n  if (state.changingStart) return changeStartFunc;\r\n  else if (state.changingEnd) return changeEndFunc;\r\n}\r\n////////////// BIN ////////////////////////////\r\n\r\n// generateMaze = () => {\r\n//     const grid = generateMaze();\r\n//     for(let i = 0; i < numRow; i++){\r\n//         for(let j = 0; j < numCol; j++){\r\n//             document.getElementById(`${i}-${j}`).innerHTML = \"\";\r\n//         }\r\n//     }\r\n//     this.setState({\r\n//         grid:grid,\r\n//     })\r\n//     visitedCells = [];\r\n//     pathFound = false;\r\n// }\r\n\r\n// showPath = () => {\r\n//     if(pathFound){\r\n//         const {grid} = this.state;\r\n//         const lastCell = grid[endRow][endCol];\r\n//         let temp = lastCell\r\n\r\n//         //shortest path\r\n//         const path = [];\r\n//         while(temp !== null){\r\n//             path.push(temp);\r\n//             temp = temp.previousCell\r\n//         }\r\n\r\n//         path.shift();\r\n//         path.pop();\r\n//         for(let i = 0; i < path.length; i++){\r\n//             document.getElementById(`${path[i].row}-${path[i].col}`).className = \"cell path\";\r\n//         }\r\n\r\n//     }\r\n// }\r\n\r\n// findPath = () => {\r\n//     const {grid} = this.state;\r\n\r\n//     const startCell = grid[startRow][startCol];\r\n//     const endCell = grid[endRow][endCol];\r\n//     visitedCells = dijkstra(grid,startCell,endCell);\r\n//     visitedCells.shift();\r\n//     visitedCells.pop();\r\n//     iter = 0;\r\n\r\n//     pathFound = true;\r\n\r\n// }\r\n\r\n// nextStep = () => {\r\n//     //const {visitedCells} = this.state;\r\n//     if(visitedCells.length === 0) return\r\n//     const cell = visitedCells[iter];\r\n//     const el = document.getElementById(`${cell.row}-${cell.col}`)\r\n//     el.className = \"cell visited\";\r\n//     el.innerHTML = `<b>${cell.distance}</b>`\r\n//     iter++;\r\n// }\r\n\r\n// const copyGrid = (grid) => {\r\n//     const newGrid = makeGrid();\r\n\r\n//     for(let i = 0; i < numRow; i++){\r\n//         for(let j = 0; j < numCol; j++){\r\n//             newGrid[i][j].row = grid[i][j].row;\r\n//             newGrid[i][j].col = grid[i][j].col;\r\n//             newGrid[i][j].isStart = grid[i][j].isStart;\r\n//             newGrid[i][j].isFinish = grid[i][j].isFinish;\r\n//             newGrid[i][j].isWall = grid[i][j].isWall;\r\n//             newGrid[i][j].previousCell = grid[i][j].previousCell;\r\n//             newGrid[i][j].distance = grid[i][j].distance;\r\n//             newGrid[i][j].isVisited = grid[i][j].isVisited;\r\n//         }\r\n//     }\r\n//     return newGrid\r\n// }\r\n\r\n// generateMaze = () => {\r\n//     const grid = generateMaze();\r\n//     this.setState({\r\n//         grid:grid,\r\n//     })\r\n//     pathFound = false;\r\n// }\r\n\r\n// handleClick = (e) => {\r\n//   if (this.state.drawingWalls) return;\r\n//   const coords = e.target.id.split(\"-\");\r\n//   const { grid, startCellCoords, endCellCoords } = this.state;\r\n\r\n//   grid[startCellCoords.row][startCellCoords.col].isStart = false;\r\n//   grid[coords[0]][coords[1]].isStart = true;\r\n\r\n//   this.setState({\r\n//     grid: grid,\r\n//     startCellCoords: {\r\n//       row: coords[0],\r\n//       col: coords[1],\r\n//     },\r\n//   });\r\n// };\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Visualiser from \"./visualiser/components/visualiser\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Visualiser />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}