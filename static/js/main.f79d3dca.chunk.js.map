{"version":3,"sources":["visualiser/components/cell.jsx","visualiser/components/legend.jsx","visualiser/algorithms/dijkstra.js","visualiser/algorithms/astar.js","visualiser/components/visualiser.jsx","index.js"],"names":["Cell","this","props","col","row","isFinish","isStart","isWall","isPath","cName","isVisited","className","id","React","Component","Legend","dijkstra","grid","startCell","finishCell","visitedCellsInOrder","distance","unVisitedCells","getCells","length","sort","nodeA","nodeB","closestCell","shift","Infinity","push","updateUnvisitedNeighbors","cell","unvisitedNeighbors","getNeighbors","filter","neighbor","previousCell","numCol","numRow","neighbors","listOfCells","i","j","astar","openSet","closedSet","visitedInOrder","lowestIndex","f","current","removeFromArray","includes","tempG","g","h","heuristic","a","b","Math","abs","arr","element","splice","Visualiser","makeCell","state","startCellCoords","endCellCoords","makeGrid","curCol","resetGrid","animationInProccess","setState","drawingWalls","mouseClicked","changingStart","changingEnd","aStarSolve","endCell","animate","then","data","delay","newGrid","animatePath","dijkstraSolve","animationSpeed","Promise","resolve","reject","setTimeout","document","getElementById","temp","path","ms","res","handleAnimationSpeed","e","target","value","changeStartHandler","changeEndHandler","changeEndCell","cellCoords","split","parseInt","changeStartCell","handlePress","coords","tempGrid","handleMouseDown","handleMouseUp","sizing","width","window","innerWidth","reSizing","visitedCells","clickOption","onload","addEventListener","onClick","onChange","defaultValue","hidden","disabled","onMouseMove","onMouseDown","onMouseUp","chooseFunction","map","rowId","key","cellId","handleClick","handleMousePress","href","changeEndFunc","changeStartFunc","ReactDOM","render","StrictMode"],"mappings":"4PAEqBA,G,6KACT,IAAD,EAUHC,KAAKC,MARPC,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,SACAC,EALK,EAKLA,QACAC,EANK,EAMLA,OACAC,EAPK,EAOLA,OAKEC,EAAQ,OAQZ,OApBO,EAQLC,YAMaD,EAAQ,gBACnBD,IAAQC,EAAQ,aAChBJ,IAAUI,EAAQ,eAClBH,IAASG,EAAQ,cACjBF,IAAQE,EAAQ,aAGlB,yBAAKE,UAAWF,EAAOG,GAAE,UAAKR,EAAL,YAAYD,IAClCG,EAAU,uBAAGK,UAAU,uBAA4B,KACnDN,EAAW,uBAAGM,UAAU,wBAA6B,U,GAxB5BE,IAAMC,YCAnBC,E,uKAEjB,OACE,6BAASJ,UAAU,UACjB,yBAAKA,UAAU,yBACb,uCAGF,yBAAKA,UAAU,yBACb,uCAGF,yBAAKA,UAAU,4BACb,0CAGF,yBAAKA,UAAU,0BACb,wCAGF,yBAAKA,UAAU,2BACb,8C,GArB0BE,IAAMC,W,OCF7BE,EAAW,SAACC,EAAMC,EAAWC,GACxC,IAAMC,EAAsB,GAC5BF,EAAUG,SAAW,EAErB,IADA,IAAMC,EAAiBC,EAASN,GACzBK,EAAeE,QAAQ,CAC5BF,EAAeG,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAML,SAAWM,EAAMN,YAC7D,IAAMO,EAAcN,EAAeO,QACnC,IAAID,EAAYrB,OAAhB,CACA,GAAIqB,EAAYP,WAAaS,IAAU,OAAOV,EAG9C,GAFAQ,EAAYlB,WAAY,EACxBU,EAAoBW,KAAKH,GACrBA,IAAgBT,EAAY,OAAOC,EACvCY,EAAyBJ,EAAaX,MAIpCe,EAA2B,SAACC,EAAMhB,GACtC,IAD+C,EACzCiB,EAAqBC,EAAaF,EAAMhB,GAAMmB,QAClD,SAACC,GAAD,OAAeA,EAAS3B,aAFqB,cAIxBwB,GAJwB,IAI/C,2BAA2C,CAAC,IAAjCG,EAAgC,QACzCA,EAAShB,SAAWY,EAAKZ,SAAW,EACpCgB,EAASC,aAAeL,GANqB,gCAU3CE,EAAe,SAACF,EAAMhB,GAC1B,IAAMsB,EAAStB,EAAK,GAAGO,OACjBgB,EAASvB,EAAKO,OACdiB,EAAY,GACVtC,EAAa8B,EAAb9B,IAAKC,EAAQ6B,EAAR7B,IAOb,OALID,EAAM,GAAK,GAAGsC,EAAUV,KAAKd,EAAKb,GAAKD,EAAM,IAC7CA,EAAM,EAAIoC,GAAQE,EAAUV,KAAKd,EAAKb,GAAKD,EAAM,IACjDC,EAAM,EAAIoC,GAAQC,EAAUV,KAAKd,EAAKb,EAAM,GAAGD,IAC/CC,EAAM,GAAK,GAAGqC,EAAUV,KAAKd,EAAKb,EAAM,GAAGD,IAExCsC,GAGHlB,EAAW,SAACN,GAKhB,IAJA,IAAMyB,EAAc,GACdH,EAAStB,EAAK,GAAGO,OACjBgB,EAASvB,EAAKO,OAEXmB,EAAI,EAAGA,EAAIH,EAAQG,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAQK,IAC1BF,EAAYX,KAAKd,EAAK0B,GAAGC,IAG7B,OAAOF,GClDIG,EAAQ,SAAC5B,EAAMC,EAAWC,GACnC,IAAM2B,EAAU,GACVC,EAAY,GAClBD,EAAQf,KAAKd,EAAKC,EAAUd,KAAKc,EAAUf,MAG3C,IAFA,IAAM6C,EAAiB,GAEjBF,EAAQtB,OAAS,GAAE,CAErB,IADA,IAAIyB,EAAc,EACVN,EAAI,EAAGA,EAAIG,EAAQtB,OAAQmB,IAC5BG,EAAQH,GAAGO,EAAIJ,EAAQG,GAAaC,IACnCD,EAAcN,GAItB,GAAGG,EAAQG,KAAiB9B,EAExB,OAAO6B,EAGX,IAAMG,EAAUL,EAAQG,GACxBD,EAAejB,KAAKoB,GAEpBC,EAAgBN,EAAQK,GACxBJ,EAAUhB,KAAKoB,GAIf,IADA,IAAMV,EAAYN,EAAagB,EAAQlC,GAC/B0B,EAAI,EAAGA,EAAIF,EAAUjB,OAAQmB,IAAI,CACrC,IAAIN,EAAWI,EAAUE,GACzB,GAAGN,EAAS9B,OACRwC,EAAUhB,KAAKM,QAInB,GADAW,EAAejB,KAAKM,IAChBU,EAAUM,SAAShB,GAAU,CAE7B,IAAIiB,EAAQrC,EAAKkC,EAAQ/C,KAAK+C,EAAQhD,KAAKoD,EAAI,EAC5CT,EAAQO,SAAShB,GACbiB,EAAQjB,EAASkB,IAChBlB,EAASkB,EAAID,IAGjBjB,EAASkB,EAAID,EACbR,EAAQf,KAAKM,IAGjBA,EAASmB,EAAIC,EAAUpB,EAASlB,GAChCkB,EAASa,EAAIb,EAASkB,EAAIlB,EAASmB,EACnCnB,EAASC,aAAea,IAKpC,OAAOH,GAsBLS,EAAY,SAACC,EAAEC,GACjB,OAAGD,EAAEtD,MAAQuD,EAAEvD,IAAYwD,KAAKC,IAAIH,EAAEvD,IAAIwD,EAAExD,KACzCuD,EAAEvD,MAAQwD,EAAExD,IAAYyD,KAAKC,IAAIH,EAAEtD,IAAIuD,EAAEvD,KACrCwD,KAAKC,IAAIH,EAAEtD,IAAIuD,EAAEvD,KAAOwD,KAAKC,IAAIH,EAAEvD,IAAIwD,EAAExD,MAK9CiD,EAAkB,SAACU,EAAIC,GACzB,IAAI,IAAIpB,EAAImB,EAAItC,OAAO,EAAGmB,GAAI,EAAGA,IAC1BmB,EAAInB,KAAKoB,GACRD,EAAIE,OAAOrB,EAAE,IAKnBR,EAAe,SAACF,EAAMhB,GACxB,IAAMsB,EAAStB,EAAK,GAAGO,OACjBgB,EAASvB,EAAKO,OACdiB,EAAY,GACVtC,EAAa8B,EAAb9B,IAAKC,EAAQ6B,EAAR7B,IAOb,OALID,EAAM,GAAK,GAAGsC,EAAUV,KAAKd,EAAKb,GAAKD,EAAM,IAC7CA,EAAM,EAAIoC,GAAQE,EAAUV,KAAKd,EAAKb,GAAKD,EAAM,IACjDC,EAAM,EAAIoC,GAAQC,EAAUV,KAAKd,EAAKb,EAAM,GAAGD,IAC/CC,EAAM,GAAK,GAAGqC,EAAUV,KAAKd,EAAKb,EAAM,GAAGD,IAExCsC,GC9FPF,EAAS,GAodE0B,E,kDAjdb,aAAe,IAAD,8BACZ,gBAuBFC,SAAW,SAAC9D,EAAKD,GAAS,IAAD,EACoB,EAAKgE,MAAxCC,EADe,EACfA,gBAAiBC,EADF,EACEA,cACzB,MAAO,CACLjE,IAAKA,EACLD,IAAKA,EACLG,QAASF,IAAQgE,EAAgBhE,KAAOD,IAAQiE,EAAgBjE,IAChEE,SAAUD,IAAQiE,EAAcjE,KAAOD,IAAQkE,EAAclE,IAC7DI,QAAQ,EACR+B,aAAc,KACdjB,SAAUS,IACVpB,WAAW,EACXF,QAAQ,EACR+C,EAAG,EACHL,EAAG,EACHM,EAAG,IAtCO,EAyCdc,SAAW,WAET,IADA,IAAMrD,EAAO,GACJ0B,EAAI,EAAGA,EA/CP,GA+CmBA,IAAK,CAE/B,IADA,IAAM4B,EAAS,GACN3B,EAAI,EAAGA,EAAIL,EAAQK,IAC1B2B,EAAOxC,KAAK,EAAKmC,SAASvB,EAAGC,IAE/B3B,EAAKc,KAAKwC,GAEZ,OAAOtD,GAlDK,EAqDduD,UAAY,WACN,EAAKL,MAAMM,qBASf,EAAKC,SAAS,CACZzD,KAAM,EAAKqD,WACXK,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,aAAa,KApEH,EAyEdC,WAzEc,sBAyED,4CAAArB,EAAA,0DACP,EAAKS,MAAMM,oBADJ,iDAMX,IANW,EAEsC,EAAKN,MAA9CC,EAFG,EAEHA,gBAAiBC,EAFd,EAEcA,cAAepD,EAF7B,EAE6BA,KAClCC,EAAYD,EAAKmD,EAAgBhE,KAAKgE,EAAgBjE,KACtD6E,EAAU/D,EAAKoD,EAAcjE,KAAKiE,EAAclE,KAE7CwC,EAAI,EAAGA,EAAIJ,EAAQI,IAC1B,IAASC,EAAI,EAAGA,EApFT,GAoFqBA,IAC1B3B,EAAK2B,GAAGD,GAAGjC,WAAY,EACvBO,EAAK2B,GAAGD,GAAGnC,QAAS,EATb,gBAYL,EAAKkE,SAAS,CAClBzD,KAAMA,EACNwD,qBAAqB,IAdZ,OAiBLrD,EAAsByB,EAAM5B,EAAMC,EAAW8D,GAEpC,EAAKC,QAAQ7D,GAEzB8D,KADH,uCACQ,WAAOC,GAAP,SAAAzB,EAAA,sEACE,EAAK0B,MAAMD,EAAK,IADlB,gCAEGA,EAAK,IAFR,2CADR,uDAKGD,MAAK,SAACjE,GACL,IAAMoE,EAAU,EAAKC,YAAYrE,GACjC,EAAKyD,SAAS,CAAEzD,KAAMoE,EAASZ,qBAAqB,OA3B7C,4CAzEC,EAwGdc,cAxGc,sBAwGE,4CAAA7B,EAAA,0DACV,EAAKS,MAAMM,oBADD,iDAGd,IAHc,EAEmC,EAAKN,MAA9ClD,EAFM,EAENA,KAAMmD,EAFA,EAEAA,gBAAiBC,EAFjB,EAEiBA,cACtB1B,EAAI,EAAGA,EAAIJ,EAAQI,IAC1B,IAASC,EAAI,EAAGA,EAhHT,GAgHqBA,IAC1B3B,EAAK2B,GAAGD,GAAGjC,WAAY,EACvBO,EAAK2B,GAAGD,GAAGnC,QAAS,EANV,gBASR,EAAKkE,SAAS,CAClBzD,KAAMA,EACNwD,qBAAqB,IAXT,OAaRvD,EAAYD,EAAKmD,EAAgBhE,KAAKgE,EAAgBjE,KACtD6E,EAAU/D,EAAKoD,EAAcjE,KAAKiE,EAAclE,KAEhDiB,EAAsBJ,EAASC,EAAMC,EAAW8D,GAEvC,EAAKC,QAAQ7D,GAEzB8D,KADH,uCACQ,WAAOC,GAAP,SAAAzB,EAAA,sEACE,EAAK0B,MAAMD,EAAK,IADlB,gCAEGA,EAAK,IAFR,2CADR,uDAKGD,MAAK,SAACjE,GACL,IAAMoE,EAAU,EAAKC,YAAYrE,GACjC,EAAKyD,SAAS,CAAEzD,KAAMoE,EAASZ,qBAAqB,OA1B1C,4CAxGF,EAuIdQ,QAAU,SAAC7D,GAAyB,IAAD,EACgC,EAAK+C,MAA9DlD,EADyB,EACzBA,KAAMoD,EADmB,EACnBA,cAAeD,EADI,EACJA,gBAAiBoB,EADb,EACaA,eAC9C,OAAO,IAAIC,SAAQ,SAAUC,EAASC,GACpC,IAD6C,IAAD,WACnChD,GACP,IAAMvC,EAAMgB,EAAoBuB,GAAGvC,IAC7BD,EAAMiB,EAAoBuB,GAAGxC,IACnC,GACGC,IAAQgE,EAAgBhE,KAAOD,IAAQiE,EAAgBjE,KACvDC,IAAQiE,EAAcjE,KAAOD,IAAQkE,EAAclE,IAEpD,iBACFyF,YAAW,WACT3E,EAAKb,GAAKD,GAAKO,WAAY,EAC3BmF,SAASC,eAAT,UAA2B1F,EAA3B,YAAkCD,IAAOQ,UAAY,iBACpDgC,EAAI6C,IAXA7C,EAAI,EAAGA,EAAIvB,EAAoBI,OAAQmB,IAAK,EAA5CA,GAaT+C,EAAQ,CAACzE,EAAMG,EAAoBI,OAASgE,QAvJlC,EA0JdF,YAAc,SAACrE,GAOb,IAPuB,IAAD,EACqB,EAAKkD,MAAxCE,EADc,EACdA,cAAeD,EADD,EACCA,gBAEnB2B,EADa9E,EAAKoD,EAAcjE,KAAKiE,EAAclE,KAIjD6F,EAAO,GACG,OAATD,GACLC,EAAKjE,KAAKgE,GACVA,EAAOA,EAAKzD,aAGd,IAAK,IAAIK,EAAI,EAAGA,EAAIqD,EAAKxE,OAAS,EAAGmB,IAAK,CACxC,IAAIvC,EAAM4F,EAAKrD,GAAGvC,IACdD,EAAM6F,EAAKrD,GAAGxC,IAEfC,IAAQgE,EAAgBhE,KAAOD,IAAQiE,EAAgBjE,KACvDC,IAAQiE,EAAcjE,KAAOD,IAAQkE,EAAclE,MAGtDc,EAAKb,GAAKD,GAAKK,QAAS,EACxBqF,SAASC,eAAT,UAA2B1F,EAA3B,YAAkCD,IAAOQ,UAAY,aAEvD,OAAOM,GAjLK,EAmLdmE,MAAQ,SAACa,GACP,OAAO,IAAIR,SAAQ,SAACS,GAAD,OAASN,WAAWM,EAAKD,OApLhC,EAwLdE,qBAAuB,SAACC,GACtB,IAAI,EAAKjC,MAAMM,oBACf,OAAQ2B,EAAEC,OAAOC,OACf,IAAK,OACH,EAAK5B,SAAS,CAAEc,eAAgB,IAChC,MACF,IAAK,UACH,EAAKd,SAAS,CAAEc,eAAgB,KAChC,MACF,IAAK,OACH,EAAKd,SAAS,CAAEc,eAAgB,OAlMxB,EAyMde,mBAAqB,WACf,EAAKpC,MAAMM,qBACf,EAAKC,SAAS,CACZG,eAAe,EACfC,aAAa,EACbH,cAAc,KA9MJ,EAiNd6B,iBAAmB,WACb,EAAKrC,MAAMM,qBACf,EAAKC,SAAS,CACZI,aAAa,EACbD,eAAe,EACfF,cAAc,KAtNJ,EA0NdA,aAAe,WACT,EAAKR,MAAMM,qBACf,EAAKC,SAAS,CACZC,cAAc,EACdE,eAAe,EACfC,aAAa,KA/NH,EAoOd2B,cAAgB,SAACL,GACf,IAAI,EAAKjC,MAAMM,oBAAf,CACA,IAAMiC,EAAaN,EAAEC,OAAOzF,GAAG+F,MAAM,KACrC,KAAID,EAAWlF,OAAS,GAAxB,CAHqB,MAKW,EAAK2C,MAA7BE,EALa,EAKbA,cAAepD,EALF,EAKEA,KACvBA,EAAKoD,EAAcjE,KAAKiE,EAAclE,KAAKE,UAAW,EACtDY,EAAKyF,EAAW,IAAIA,EAAW,IAAIrG,UAAW,EAC9C,EAAKqE,SAAS,CACZzD,KAAMA,EACNoD,cAAe,CACbjE,IAAKwG,SAASF,EAAW,IACzBvG,IAAKyG,SAASF,EAAW,UAhPjB,EAoPdG,gBAAkB,SAACT,GACjB,IAAI,EAAKjC,MAAMM,oBAAf,CACA,IAAMiC,EAAaN,EAAEC,OAAOzF,GAAG+F,MAAM,KACrC,KAAID,EAAWlF,OAAS,GAAxB,CAHuB,MAKW,EAAK2C,MAA/BC,EALe,EAKfA,gBAAiBnD,EALF,EAKEA,KACzBA,EAAKmD,EAAgBhE,KAAKgE,EAAgBjE,KAAKG,SAAU,EACzDW,EAAKyF,EAAW,IAAIA,EAAW,IAAIpG,SAAU,EAC7C,EAAKoE,SAAS,CACZzD,KAAMA,EACNmD,gBAAiB,CACfhE,IAAKwG,SAASF,EAAW,IACzBvG,IAAKyG,SAASF,EAAW,UAhQjB,EAsQdI,YAAc,SAACV,GACb,IAAI,EAAKjC,MAAMM,oBAAf,CACA,IAAMsC,EAASX,EAAEC,OAAOzF,GAAG+F,MAAM,KAC7BI,EAAOvF,OAAS,GAEjBoF,SAASG,EAAO,MAAQ,EAAK5C,MAAMC,gBAAgBhE,KAClDwG,SAASG,EAAO,MAAQ,EAAK5C,MAAMC,gBAAgBjE,KACpDyG,SAASG,EAAO,MAAQ,EAAK5C,MAAME,cAAcjE,KAChDwG,SAASG,EAAO,MAAQ,EAAK5C,MAAME,cAAclE,MAGrD0F,SAASC,eAAT,UAA2BiB,EAAO,GAAlC,YAAwCA,EAAO,KAAMpG,UACnD,YACF,EAAKqG,SAASD,EAAO,IAAIA,EAAO,IAAIxG,QAAS,KAnRjC,EAqRd0G,gBAAkB,WACZ,EAAK9C,MAAMM,sBACf,EAAKuC,SAAW,EAAK7C,MAAMlD,KAC3B,EAAKyD,SAAS,CACZE,cAAc,MAzRJ,EA4RdsC,cAAgB,WACV,EAAK/C,MAAMM,qBACf,EAAKC,SAAS,CACZE,cAAc,EACd3D,KAAM,EAAK+F,YAhSD,EAqSdG,OArSc,sBAqSL,8BAAAzD,EAAA,0DACH,EAAKS,MAAMM,oBADR,wDAED2C,EAAQC,OAAOC,WAEnB/E,EADE6E,GAAS,IACF,GACAA,EAAQ,KAAOA,GAAS,KACxB,GACAA,EAAQ,MAAQA,EAAQ,KACxB,GAEA,GAVJ,SAaD,EAAK1C,SAAS,CAClBN,gBAAiB,CACfhE,IAAK,GACLD,IAAKyG,SAASrE,EAAS,IAEzB8B,cAAe,CACbjE,IAAK,GACLD,IAAKyG,SAAUrE,EAAS,EAAK,MApB1B,OAwBDtB,EAAO,EAAKqD,WAClB,EAAKI,SAAS,CACZzD,KAAMA,IA1BD,2CArSK,EAkUdsG,SAlUc,sBAkUH,8BAAA7D,EAAA,0DACL,EAAKS,MAAMM,oBADN,wDAEH2C,EAAQC,OAAOC,WAEnB/E,EADE6E,GAAS,IACF,GACAA,EAAQ,KAAOA,GAAS,KACxB,GACAA,EAAQ,MAAQA,EAAQ,KACxB,GAEA,GAVF,SAYH,EAAK1C,SAAS,CAClBN,gBAAiB,CACfhE,IAAK,GACLD,IAAKyG,SAASrE,EAAS,IAEzB8B,cAAe,CACbjE,IAAK,GACLD,IAA4B,EAAvByG,SAASrE,EAAS,MAnBlB,OAuBHtB,EAAO,EAAKqD,WAElB,EAAKI,SAAS,CACZzD,KAAMA,IA1BC,2CAhUT,EAAKkD,MAAQ,CACXlD,KAAM,GACNuG,aAAc,GACdpD,gBAAiB,CACfhE,IAAK,GACLD,IAAK,GAEPkE,cAAe,CACbjE,IAAK,GACLD,IAAK,IAEPsH,YAAa,GACb9C,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,aAAa,EACbU,eAAgB,GAChBf,qBAAqB,GAEvB,EAAKuC,SAAW,KArBJ,E,gEAiWZK,OAAOK,OAASzH,KAAKkH,OACrBE,OAAOM,iBAAiB,SAAU1H,KAAKsH,Y,+BAG/B,IAAD,OACDtG,EAAOhB,KAAKkE,MAAMlD,KADjB,EAEgChB,KAAKkE,MAApCQ,EAFD,EAECA,aAAcC,EAFf,EAEeA,aACtB,OACE,8BACE,6BAASjE,UAAU,QACjB,kBAAC,EAAD,MACA,6BAASA,UAAU,aACjB,6BAASA,UAAU,qBACjB,4BAAQiH,QAAS3H,KAAKsF,eACpB,2CAEF,4BAAQqC,QAAS3H,KAAK8E,YACpB,sCAGJ,6BAASpE,UAAU,gBACjB,4BACEC,GAAG,iBACHiH,SAAU5H,KAAKkG,qBACf2B,aAAc,SAEd,4BAAQC,QAAM,EAACC,UAAQ,EAAC1B,MAAM,SAA9B,SAGA,4BAAQA,MAAM,QAAd,QACA,4BAAQA,MAAM,WAAd,WACA,4BAAQA,MAAM,QAAd,SAEF,4BAAQsB,QAAS3H,KAAKuE,UAAW7D,UAAU,aACzC,wCAEF,4BAAQiH,QAAS3H,KAAK0E,aAAchE,UAAU,YAC5C,4CAEF,4BAAQiH,QAAS3H,KAAKsG,mBAAoB5F,UAAU,aAClD,+CAEF,4BAAQiH,QAAS3H,KAAKuG,iBAAkB7F,UAAU,cAChD,gDAKR,6BACEA,UAAU,OACVC,GAAG,OACHqH,YAAatD,GAAgBC,EAAe3E,KAAK6G,YAAc,KAC/DoB,YAAavD,EAAe1E,KAAKgH,gBAAkB,KACnDkB,UAAWxD,EAAe1E,KAAKiH,cAAgB,KAC/CU,QAASQ,EACPnI,KAAKkE,MACLlE,KAAKwG,cACLxG,KAAK4G,kBAGN5F,EAAKoH,KAAI,SAACjI,EAAKkI,GACd,OACE,yBAAKC,IAAKD,EAAO3H,UAAU,OACxBP,EAAIiI,KAAI,SAACpG,EAAMuG,GAAY,IAExBpI,EAOE6B,EAPF7B,IACAD,EAME8B,EANF9B,IACAG,EAKE2B,EALF3B,QACAD,EAIE4B,EAJF5B,SACAE,EAGE0B,EAHF1B,OACAG,EAEEuB,EAFFvB,UACAF,EACEyB,EADFzB,OAEF,OACE,kBAAC,EAAD,CACE+H,IAAKC,EACLpI,IAAKA,EACLD,IAAKA,EACLG,QAASA,EACTD,SAAUA,EACVE,OAAQA,EACRG,UAAWA,EACXF,OAAQA,EACRiI,YAAa,EAAKA,YAClBC,iBAAkB,EAAKA,iBACvBxB,cAAe,EAAKA,wBAQlC,gCACE,yBAAKvG,UAAU,WACb,uBAAGgI,KAAK,6BACN,uBAAGhI,UAAU,0BAEf,uBAAGgI,KAAK,2DACN,uBAAGhI,UAAU,qBAEf,uBAAGgI,KAAK,mCACN,uBAAGhI,UAAU,6BAGjB,iE,GA3ceE,IAAMC,WAod/B,SAASsH,EAAejE,EAAOyE,EAAeC,GAC5C,OAAI1E,EAAMU,cAAsBgE,EACvB1E,EAAMW,YAAoB8D,OAA9B,EC3dPE,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFnD,SAASC,eAAe,W","file":"static/js/main.f79d3dca.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nexport default class Cell extends React.Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      isPath,\r\n      isVisited,\r\n      //distance\r\n    } = this.props;\r\n\r\n    let cName = \"cell\";\r\n\r\n    if (isVisited) cName = \"cell visited\";\r\n    if (isPath) cName = \"cell path\";\r\n    if (isFinish) cName = \"cell finish\";\r\n    if (isStart) cName = \"cell start\";\r\n    if (isWall) cName = \"cell wall\";\r\n\r\n    return (\r\n      <div className={cName} id={`${row}-${col}`}>\r\n        {isStart ? <i className=\"far fa-play-circle\"></i> : null}\r\n        {isFinish ? <i className=\"far fa-times-circle\"></i> : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\n\r\nexport default class Legend extends React.Component {\r\n  render() {\r\n    return (\r\n      <section className=\"legend\">\r\n        <div className=\"legendCell pathLegend\">\r\n          <span>Path</span>\r\n        </div>\r\n\r\n        <div className=\"legendCell wallLegend\">\r\n          <span>Wall</span>\r\n        </div>\r\n\r\n        <div className=\"legendCell visitedLegend\">\r\n          <span>Visited</span>\r\n        </div>\r\n\r\n        <div className=\"legendCell startLegend\">\r\n          <span>Start</span>\r\n        </div>\r\n\r\n        <div className=\"legendCell finishLegend\">\r\n          <span>Finish</span>\r\n        </div>\r\n      </section>\r\n    );\r\n  }\r\n}\r\n","export const dijkstra = (grid, startCell, finishCell) => {\r\n  const visitedCellsInOrder = [];\r\n  startCell.distance = 0;\r\n  const unVisitedCells = getCells(grid);\r\n  while (unVisitedCells.length) {\r\n    unVisitedCells.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); // min heap better option\r\n    const closestCell = unVisitedCells.shift();\r\n    if (closestCell.isWall) continue;\r\n    if (closestCell.distance === Infinity) return visitedCellsInOrder;\r\n    closestCell.isVisited = true;\r\n    visitedCellsInOrder.push(closestCell);\r\n    if (closestCell === finishCell) return visitedCellsInOrder;\r\n    updateUnvisitedNeighbors(closestCell, grid);\r\n  }\r\n};\r\n\r\nconst updateUnvisitedNeighbors = (cell, grid) => {\r\n  const unvisitedNeighbors = getNeighbors(cell, grid).filter(\r\n    (neighbor) => !neighbor.isVisited\r\n  );\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = cell.distance + 1;\r\n    neighbor.previousCell = cell;\r\n  }\r\n};\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n  const neighbors = [];\r\n  const { col, row } = cell;\r\n\r\n  if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n  if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n  if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n  if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n\r\n  return neighbors;\r\n};\r\n\r\nconst getCells = (grid) => {\r\n  const listOfCells = [];\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n\r\n  for (let i = 0; i < numRow; i++) {\r\n    for (let j = 0; j < numCol; j++) {\r\n      listOfCells.push(grid[i][j]);\r\n    }\r\n  }\r\n  return listOfCells;\r\n};\r\n","export const astar = (grid, startCell, finishCell) => {\r\n    const openSet = [];     \r\n    const closedSet = [];   \r\n    openSet.push(grid[startCell.row][startCell.col])\r\n    const visitedInOrder = [];\r\n\r\n    while(openSet.length > 0){\r\n        let lowestIndex = 0;\r\n        for(let i = 0; i < openSet.length; i++){\r\n            if(openSet[i].f < openSet[lowestIndex].f){\r\n                lowestIndex = i;\r\n            }\r\n        }\r\n        \r\n        if(openSet[lowestIndex] === finishCell){\r\n            //return path(finishCell);\r\n            return visitedInOrder;\r\n        }\r\n        \r\n        const current = openSet[lowestIndex]\r\n        visitedInOrder.push(current)\r\n\r\n        removeFromArray(openSet,current) //spllice(lowestIndex,1) ??\r\n        closedSet.push(current)\r\n        //grid[current.row][current.col].isVisited = true;\r\n\r\n        const neighbors = getNeighbors(current,grid);\r\n        for(let i = 0; i < neighbors.length; i++){\r\n            let neighbor = neighbors[i];\r\n            if(neighbor.isWall){\r\n                closedSet.push(neighbor)\r\n                continue;\r\n            }\r\n            visitedInOrder.push(neighbor)\r\n            if(!closedSet.includes(neighbor)){\r\n                //grid[neighbor.row][neighbor.col].g = grid[current.row][current.col].g + 1\r\n                let tempG = grid[current.row][current.col].g + 1\r\n                if(openSet.includes(neighbor)){\r\n                    if(tempG < neighbor.g){\r\n                        neighbor.g = tempG;\r\n                    }\r\n                }else{\r\n                    neighbor.g = tempG;\r\n                    openSet.push(neighbor);\r\n                }\r\n\r\n                neighbor.h = heuristic(neighbor,finishCell)\r\n                neighbor.f = neighbor.g + neighbor.h\r\n                neighbor.previousCell = current;\r\n            }\r\n            \r\n        }\r\n    }\r\n    return visitedInOrder;\r\n    //return grid;\r\n    // const path = [];\r\n    // let end = finishCell\r\n    // while(end.previousCell !== startCell){\r\n    //     path.push(end)\r\n    //     end = end.previousCell\r\n    // }\r\n    // return path;\r\n\r\n\r\n};\r\n\r\n// const path = (endCell) => {\r\n//     const path = [];\r\n//     while(endCell.previousCell != null){\r\n//         path.push(endCell)\r\n//         endCell = endCell.previousCell;\r\n//     }\r\n//     return path;\r\n// }\r\n\r\nconst heuristic = (a,b) => {\r\n    if(a.row === b.row) return Math.abs(a.col-b.col)\r\n    if(a.col === b.col) return Math.abs(a.row-b.row)\r\n    return Math.abs(a.row-b.row) + Math.abs(a.col-b.col)\r\n    //pythagoras a^2 + b^2 = c^2\r\n    //return Math.sqrt(Math.abs(a.col-b.col)+Math.abs(a.row-b.row))\r\n}\r\n  \r\nconst removeFromArray = (arr,element) => {\r\n    for(let i = arr.length-1; i >=0; i--){\r\n        if(arr[i]===element){\r\n            arr.splice(i,1);\r\n        }\r\n    }\r\n}\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n    const numCol = grid[0].length;\r\n    const numRow = grid.length;\r\n    const neighbors = [];\r\n    const { col, row } = cell;\r\n  \r\n    if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n    if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n    if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n    if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n  \r\n    return neighbors;\r\n  };\r\n  ","import React from \"react\";\r\nimport \"./styles/visualiser.scss\";\r\nimport Cell from \"./cell\";\r\nimport Legend from \"./legend\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { astar } from \"../algorithms/astar\";\r\n\r\nlet numRow = 20;\r\nlet numCol = 50;\r\n\r\nclass Visualiser extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      visitedCells: [],\r\n      startCellCoords: {\r\n        row: 10,\r\n        col: 8,\r\n      },\r\n      endCellCoords: {\r\n        row: 10,\r\n        col: 14,\r\n      },\r\n      clickOption: \"\",\r\n      drawingWalls: false,\r\n      mouseClicked: false,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n      animationSpeed: 14,\r\n      animationInProccess: false,\r\n    };\r\n    this.tempGrid = null;\r\n  }\r\n\r\n  makeCell = (row, col) => {\r\n    const { startCellCoords, endCellCoords } = this.state;\r\n    return {\r\n      row: row,\r\n      col: col,\r\n      isStart: row === startCellCoords.row && col === startCellCoords.col,\r\n      isFinish: row === endCellCoords.row && col === endCellCoords.col,\r\n      isWall: false,\r\n      previousCell: null,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isPath: false,\r\n      g: 0,\r\n      f: 0,\r\n      h: 0,\r\n    };\r\n  };\r\n  makeGrid = () => {\r\n    const grid = [];\r\n    for (let i = 0; i < numRow; i++) {\r\n      const curCol = [];\r\n      for (let j = 0; j < numCol; j++) {\r\n        curCol.push(this.makeCell(i, j));\r\n      }\r\n      grid.push(curCol);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  resetGrid = () => {\r\n    if (this.state.animationInProccess) return;\r\n    // const { grid } = this.state;\r\n    // for (let i = 0; i < numCol; i++) {\r\n    //   for (let j = 0; j < numRow; j++) {\r\n    //     grid[j][i].isVisited = false;\r\n    //     grid[j][i].isPath = false;\r\n    //     grid[j][i].isWall = false;\r\n    //   }\r\n    // }\r\n    this.setState({\r\n      grid: this.makeGrid(),\r\n      drawingWalls: false,\r\n      mouseClicked: false,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n    });\r\n  };\r\n\r\n  //ALGORITHMS\r\n  aStarSolve = async () => {\r\n    if (this.state.animationInProccess) return;\r\n    const { startCellCoords, endCellCoords, grid } = this.state;\r\n    const startCell = grid[startCellCoords.row][startCellCoords.col];\r\n    const endCell = grid[endCellCoords.row][endCellCoords.col];\r\n\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].isPath = false;\r\n      }\r\n    }\r\n    await this.setState({\r\n      grid: grid,\r\n      animationInProccess: true,\r\n    });\r\n\r\n    const visitedCellsInOrder = astar(grid, startCell, endCell);\r\n\r\n    const result = this.animate(visitedCellsInOrder);\r\n    result\r\n      .then(async (data) => {\r\n        await this.delay(data[1]);\r\n        return data[0];\r\n      })\r\n      .then((grid) => {\r\n        const newGrid = this.animatePath(grid);\r\n        this.setState({ grid: newGrid, animationInProccess: false });\r\n      });\r\n  };\r\n\r\n  dijkstraSolve = async () => {\r\n    if (this.state.animationInProccess) return;\r\n    const { grid, startCellCoords, endCellCoords } = this.state;\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].isPath = false;\r\n      }\r\n    }\r\n    await this.setState({\r\n      grid: grid,\r\n      animationInProccess: true,\r\n    });\r\n    const startCell = grid[startCellCoords.row][startCellCoords.col];\r\n    const endCell = grid[endCellCoords.row][endCellCoords.col];\r\n\r\n    const visitedCellsInOrder = dijkstra(grid, startCell, endCell);\r\n\r\n    const result = this.animate(visitedCellsInOrder);\r\n    result\r\n      .then(async (data) => {\r\n        await this.delay(data[1]);\r\n        return data[0];\r\n      })\r\n      .then((grid) => {\r\n        const newGrid = this.animatePath(grid);\r\n        this.setState({ grid: newGrid, animationInProccess: false });\r\n      });\r\n  };\r\n\r\n  //ANIMATIONS\r\n  animate = (visitedCellsInOrder) => {\r\n    const { grid, endCellCoords, startCellCoords, animationSpeed } = this.state;\r\n    return new Promise(function (resolve, reject) {\r\n      for (let i = 1; i < visitedCellsInOrder.length; i++) {\r\n        const row = visitedCellsInOrder[i].row;\r\n        const col = visitedCellsInOrder[i].col;\r\n        if (\r\n          (row === startCellCoords.row && col === startCellCoords.col) ||\r\n          (row === endCellCoords.row && col === endCellCoords.col)\r\n        )\r\n          continue;\r\n        setTimeout(() => {\r\n          grid[row][col].isVisited = true;\r\n          document.getElementById(`${row}-${col}`).className = \"cell visited\";\r\n        }, i * animationSpeed);\r\n      }\r\n      resolve([grid, visitedCellsInOrder.length * animationSpeed]); // immediately give the result: 123\r\n    });\r\n  };\r\n  animatePath = (grid) => {\r\n    const { endCellCoords, startCellCoords } = this.state;\r\n    const lastCell = grid[endCellCoords.row][endCellCoords.col];\r\n    let temp = lastCell;\r\n\r\n    //shortest path\r\n    const path = [];\r\n    while (temp !== null) {\r\n      path.push(temp);\r\n      temp = temp.previousCell;\r\n    }\r\n\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      let row = path[i].row;\r\n      let col = path[i].col;\r\n      if (\r\n        (row === startCellCoords.row && col === startCellCoords.col) ||\r\n        (row === endCellCoords.row && col === endCellCoords.col)\r\n      )\r\n        continue;\r\n      grid[row][col].isPath = true;\r\n      document.getElementById(`${row}-${col}`).className = \"cell path\";\r\n    }\r\n    return grid;\r\n  };\r\n  delay = (ms) => {\r\n    return new Promise((res) => setTimeout(res, ms));\r\n  };\r\n\r\n  // INTERACTIONS HANDLERS\r\n  handleAnimationSpeed = (e) => {\r\n    if (this.state.animationInProccess) return;\r\n    switch (e.target.value) {\r\n      case \"fast\":\r\n        this.setState({ animationSpeed: 7 });\r\n        break;\r\n      case \"average\":\r\n        this.setState({ animationSpeed: 14 });\r\n        break;\r\n      case \"slow\":\r\n        this.setState({ animationSpeed: 25 });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n  //START / END BUTTON HANDLERS\r\n  changeStartHandler = () => {\r\n    if (this.state.animationInProccess) return;\r\n    this.setState({\r\n      changingStart: true,\r\n      changingEnd: false,\r\n      drawingWalls: false,\r\n    });\r\n  };\r\n  changeEndHandler = () => {\r\n    if (this.state.animationInProccess) return;\r\n    this.setState({\r\n      changingEnd: true,\r\n      changingStart: false,\r\n      drawingWalls: false,\r\n    });\r\n  };\r\n  //DRAW WALLS BUTTON HANDLER\r\n  drawingWalls = () => {\r\n    if (this.state.animationInProccess) return;\r\n    this.setState({\r\n      drawingWalls: true,\r\n      changingStart: false,\r\n      changingEnd: false,\r\n    });\r\n  };\r\n\r\n  //CHANGING START/END CELLS\r\n  changeEndCell = (e) => {\r\n    if (this.state.animationInProccess) return;\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { endCellCoords, grid } = this.state;\r\n    grid[endCellCoords.row][endCellCoords.col].isFinish = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isFinish = true;\r\n    this.setState({\r\n      grid: grid,\r\n      endCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n  changeStartCell = (e) => {\r\n    if (this.state.animationInProccess) return;\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { startCellCoords, grid } = this.state;\r\n    grid[startCellCoords.row][startCellCoords.col].isStart = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isStart = true;\r\n    this.setState({\r\n      grid: grid,\r\n      startCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n\r\n  //DRAG ON GRID / DRAWING WALLS\r\n  handlePress = (e) => {\r\n    if (this.state.animationInProccess) return;\r\n    const coords = e.target.id.split(\"-\");\r\n    if (coords.length < 2) return;\r\n    if (\r\n      (parseInt(coords[0]) === this.state.startCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.startCellCoords.col) ||\r\n      (parseInt(coords[0]) === this.state.endCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.endCellCoords.col)\r\n    )\r\n      return;\r\n    document.getElementById(`${coords[0]}-${coords[1]}`).className =\r\n      \"cell wall\";\r\n    this.tempGrid[coords[0]][coords[1]].isWall = true;\r\n  };\r\n  handleMouseDown = () => {\r\n    if (this.state.animationInProccess) return;\r\n    this.tempGrid = this.state.grid;\r\n    this.setState({\r\n      mouseClicked: true,\r\n    });\r\n  };\r\n  handleMouseUp = () => {\r\n    if (this.state.animationInProccess) return;\r\n    this.setState({\r\n      mouseClicked: false,\r\n      grid: this.tempGrid,\r\n    });\r\n  };\r\n\r\n  //window sizing/resizing for responsive layout\r\n  sizing = async () => {\r\n    if (this.state.animationInProccess) return;\r\n    const width = window.innerWidth;\r\n    if (width <= 576) {\r\n      numCol = 15;\r\n    } else if (width > 576 && width <= 1024) {\r\n      numCol = 25;\r\n    } else if (width > 1024 && width < 1200) {\r\n      numCol = 30;\r\n    } else {\r\n      numCol = 50;\r\n    }\r\n\r\n    await this.setState({\r\n      startCellCoords: {\r\n        row: 10,\r\n        col: parseInt(numCol / 3),\r\n      },\r\n      endCellCoords: {\r\n        row: 10,\r\n        col: parseInt((numCol / 3) * 2),\r\n      },\r\n    });\r\n\r\n    const grid = this.makeGrid();\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  };\r\n  reSizing = async () => {\r\n    if (this.state.animationInProccess) return;\r\n    const width = window.innerWidth;\r\n    if (width <= 576) {\r\n      numCol = 15;\r\n    } else if (width > 576 && width <= 1024) {\r\n      numCol = 25;\r\n    } else if (width > 1024 && width < 1200) {\r\n      numCol = 30;\r\n    } else {\r\n      numCol = 50;\r\n    }\r\n    await this.setState({\r\n      startCellCoords: {\r\n        row: 10,\r\n        col: parseInt(numCol / 3),\r\n      },\r\n      endCellCoords: {\r\n        row: 10,\r\n        col: parseInt(numCol / 3) * 2,\r\n      },\r\n    });\r\n\r\n    const grid = this.makeGrid();\r\n\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  };\r\n\r\n  componentDidMount() {\r\n    window.onload = this.sizing;\r\n    window.addEventListener(\"resize\", this.reSizing);\r\n  }\r\n\r\n  render() {\r\n    const grid = this.state.grid;\r\n    const { drawingWalls, mouseClicked } = this.state;\r\n    return (\r\n      <main>\r\n        <section className=\"menu\">\r\n          <Legend />\r\n          <section className=\"clickable\">\r\n            <section className=\"algorithmsButtons\">\r\n              <button onClick={this.dijkstraSolve}>\r\n                <span>Dijkstra</span>\r\n              </button>\r\n              <button onClick={this.aStarSolve}>\r\n                <span>A*</span>\r\n              </button>\r\n            </section>\r\n            <section className=\"interactions\">\r\n              <select\r\n                id=\"animationSpeed\"\r\n                onChange={this.handleAnimationSpeed}\r\n                defaultValue={\"Speed\"}\r\n              >\r\n                <option hidden disabled value=\"Speed\">\r\n                  Speed\r\n                </option>\r\n                <option value=\"fast\">Fast</option>\r\n                <option value=\"average\">Average</option>\r\n                <option value=\"slow\">Slow</option>\r\n              </select>\r\n              <button onClick={this.resetGrid} className=\"btn-reset\">\r\n                <span>Reset</span>\r\n              </button>\r\n              <button onClick={this.drawingWalls} className=\"btn-wall\">\r\n                <span>Add walls</span>\r\n              </button>\r\n              <button onClick={this.changeStartHandler} className=\"btn-start\">\r\n                <span>Change Start</span>\r\n              </button>\r\n              <button onClick={this.changeEndHandler} className=\"btn-finish\">\r\n                <span>Change End</span>\r\n              </button>\r\n            </section>\r\n          </section>\r\n        </section>\r\n        <section\r\n          className=\"grid\"\r\n          id=\"grid\"\r\n          onMouseMove={drawingWalls && mouseClicked ? this.handlePress : null}\r\n          onMouseDown={drawingWalls ? this.handleMouseDown : null}\r\n          onMouseUp={drawingWalls ? this.handleMouseUp : null}\r\n          onClick={chooseFunction(\r\n            this.state,\r\n            this.changeEndCell,\r\n            this.changeStartCell\r\n          )}\r\n        >\r\n          {grid.map((row, rowId) => {\r\n            return (\r\n              <div key={rowId} className=\"row\">\r\n                {row.map((cell, cellId) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    isWall,\r\n                    isVisited,\r\n                    isPath,\r\n                  } = cell;\r\n                  return (\r\n                    <Cell\r\n                      key={cellId}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      isWall={isWall}\r\n                      isVisited={isVisited}\r\n                      isPath={isPath}\r\n                      handleClick={this.handleClick}\r\n                      handleMousePress={this.handleMousePress}\r\n                      handleMouseUp={this.handleMouseUp}\r\n                    ></Cell>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </section>\r\n        <footer>\r\n          <div className=\"socials\">\r\n            <a href=\"https://github.com/fizo99\">\r\n              <i className=\"fab fa-github-square\"></i>\r\n            </a>\r\n            <a href=\"https://www.linkedin.com/in/krzysztof-huczek-a1bb36175/\">\r\n              <i className=\"fab fa-linkedin\"></i>\r\n            </a>\r\n            <a href=\"https://www.facebook.com/mvpett\">\r\n              <i className=\"fab fa-facebook-square\"></i>\r\n            </a>\r\n          </div>\r\n          <h6>© Krzysztof Huczek, 2020</h6>\r\n        </footer>\r\n      </main>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Visualiser;\r\n\r\nfunction chooseFunction(state, changeEndFunc, changeStartFunc) {\r\n  if (state.changingStart) return changeStartFunc;\r\n  else if (state.changingEnd) return changeEndFunc;\r\n}\r\n\r\n////////////// BIN ////////////////////////////\r\n\r\n// generateMaze = () => {\r\n//     const grid = generateMaze();\r\n//     for(let i = 0; i < numRow; i++){\r\n//         for(let j = 0; j < numCol; j++){\r\n//             document.getElementById(`${i}-${j}`).innerHTML = \"\";\r\n//         }\r\n//     }\r\n//     this.setState({\r\n//         grid:grid,\r\n//     })\r\n//     visitedCells = [];\r\n//     pathFound = false;\r\n// }\r\n\r\n// showPath = () => {\r\n//     if(pathFound){\r\n//         const {grid} = this.state;\r\n//         const lastCell = grid[endRow][endCol];\r\n//         let temp = lastCell\r\n\r\n//         //shortest path\r\n//         const path = [];\r\n//         while(temp !== null){\r\n//             path.push(temp);\r\n//             temp = temp.previousCell\r\n//         }\r\n\r\n//         path.shift();\r\n//         path.pop();\r\n//         for(let i = 0; i < path.length; i++){\r\n//             document.getElementById(`${path[i].row}-${path[i].col}`).className = \"cell path\";\r\n//         }\r\n\r\n//     }\r\n// }\r\n\r\n// findPath = () => {\r\n//     const {grid} = this.state;\r\n\r\n//     const startCell = grid[startRow][startCol];\r\n//     const endCell = grid[endRow][endCol];\r\n//     visitedCells = dijkstra(grid,startCell,endCell);\r\n//     visitedCells.shift();\r\n//     visitedCells.pop();\r\n//     iter = 0;\r\n\r\n//     pathFound = true;\r\n\r\n// }\r\n\r\n// nextStep = () => {\r\n//     //const {visitedCells} = this.state;\r\n//     if(visitedCells.length === 0) return\r\n//     const cell = visitedCells[iter];\r\n//     const el = document.getElementById(`${cell.row}-${cell.col}`)\r\n//     el.className = \"cell visited\";\r\n//     el.innerHTML = `<b>${cell.distance}</b>`\r\n//     iter++;\r\n// }\r\n\r\n// const copyGrid = (grid) => {\r\n//     const newGrid = makeGrid();\r\n\r\n//     for(let i = 0; i < numRow; i++){\r\n//         for(let j = 0; j < numCol; j++){\r\n//             newGrid[i][j].row = grid[i][j].row;\r\n//             newGrid[i][j].col = grid[i][j].col;\r\n//             newGrid[i][j].isStart = grid[i][j].isStart;\r\n//             newGrid[i][j].isFinish = grid[i][j].isFinish;\r\n//             newGrid[i][j].isWall = grid[i][j].isWall;\r\n//             newGrid[i][j].previousCell = grid[i][j].previousCell;\r\n//             newGrid[i][j].distance = grid[i][j].distance;\r\n//             newGrid[i][j].isVisited = grid[i][j].isVisited;\r\n//         }\r\n//     }\r\n//     return newGrid\r\n// }\r\n\r\n// generateMaze = () => {\r\n//     const grid = generateMaze();\r\n//     this.setState({\r\n//         grid:grid,\r\n//     })\r\n//     pathFound = false;\r\n// }\r\n\r\n// handleClick = (e) => {\r\n//   if (this.state.drawingWalls) return;\r\n//   const coords = e.target.id.split(\"-\");\r\n//   const { grid, startCellCoords, endCellCoords } = this.state;\r\n\r\n//   grid[startCellCoords.row][startCellCoords.col].isStart = false;\r\n//   grid[coords[0]][coords[1]].isStart = true;\r\n\r\n//   this.setState({\r\n//     grid: grid,\r\n//     startCellCoords: {\r\n//       row: coords[0],\r\n//       col: coords[1],\r\n//     },\r\n//   });\r\n// };\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Visualiser from \"./visualiser/components/visualiser\";\n// import \"./visualiser/components/styles/visualiser.less\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Visualiser />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}