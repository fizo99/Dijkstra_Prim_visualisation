{"version":3,"sources":["visualiser/components/Footer.jsx","visualiser/components/Legend.jsx","visualiser/components/Button.jsx","visualiser/components/SelectField.jsx","visualiser/algorithms/astar.js","visualiser/algorithms/dijkstra.js","visualiser/components/Menu.jsx","visualiser/components/Cell.jsx","visualiser/components/Grid.jsx","visualiser/algorithms/DFSmaze.js","visualiser/components/App.jsx","index.js"],"names":["Footer","className","href","Legend","React","Component","Button","props","onClick","handleClick","text","SelectField","id","onChange","handleAnimationSpeed","defaultValue","hidden","disabled","value","options","map","option","optionID","key","astar","grid","startCell","finishCell","openSet","closedSet","push","row","col","visitedInOrder","length","lowestIndex","i","f","current","removeFromArray","neighbors","getNeighbors","neighbor","isWall","includes","tempG","g","h","heuristic","previousCell","a","b","Math","abs","arr","element","splice","cell","numCol","numRow","dijkstra","visitedCellsInOrder","distance","unVisitedCells","getCells","sort","nodeA","nodeB","closestCell","shift","Infinity","isVisited","updateUnvisitedNeighbors","unvisitedNeighbors","filter","listOfCells","j","Menu","solve","actions","genMaze","Cell","isFinish","isStart","isPath","clickHandler","cName","Grid","changeStartCell","changeEndCell","properties","isChangingEnd","isChangingStart","rowId","cellId","DFSmaze","startCellCoords","endCellCoords","c","randomInt","r","order","recursion","randDirs","generateRandomDirections","dirs","shuffle","floor","random","min","max","ceil","delay","ms","Promise","res","setTimeout","App","makeCell","state","makeGrid","curCol","resetGrid","isAnimationInProccess","setState","isDrawingWalls","isMouseClicked","algorithm","endCell","animateVisited","then","data","newGrid","animatePath","animationSpeed","resolve","reject","document","getElementById","temp","path","e","target","changeStartHandler","changeEndHandler","cellCoords","split","parseInt","sizing","width","window","innerWidth","reSizing","tempGrid","onload","this","addEventListener","buttonActions","solveFunction","drawingWallsHandler","changeSpeedHandler","gridProperties","gridActions","handlePress","handleMouseDown","handleMouseUp","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.229331a7.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./styles/footer.css\";\r\n\r\nconst Footer = () => {\r\n  return (\r\n    <footer>\r\n      <div className=\"socials\">\r\n        <a href=\"https://github.com/fizo99\">\r\n          <i className=\"fab fa-github-square\"></i>\r\n        </a>\r\n        <a href=\"https://www.linkedin.com/in/krzysztof-huczek-a1bb36175/\">\r\n          <i className=\"fab fa-linkedin\"></i>\r\n        </a>\r\n        <a href=\"https://www.facebook.com/mvpett\">\r\n          <i className=\"fab fa-facebook-square\"></i>\r\n        </a>\r\n      </div>\r\n      <small>© Krzysztof Huczek, 2020</small>\r\n    </footer>\r\n  );\r\n};\r\nexport default Footer;\r\n","import React from \"react\";\r\nimport \"./styles/legend.css\";\r\n\r\nexport default class Legend extends React.Component {\r\n  render() {\r\n    return (\r\n      <section className=\"legend\">\r\n        <div className=\"legendCell pathLegend\">\r\n          <strong>Path</strong>\r\n        </div>\r\n        <div className=\"legendCell wallLegend\">\r\n          <strong>Wall</strong>\r\n        </div>\r\n        <div className=\"legendCell currentlyLegend\">\r\n          <strong>Current</strong>\r\n        </div>\r\n\r\n        <div className=\"legendCell visitedLegend\">\r\n          <strong>Visited</strong>\r\n        </div>\r\n\r\n        <div className=\"legendCell startLegend\">\r\n          <strong>Start</strong>\r\n        </div>\r\n\r\n        <div className=\"legendCell finishLegend\">\r\n          <strong>Finish</strong>\r\n        </div>\r\n      </section>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport \"./styles/button.css\";\r\n\r\nconst Button = (props) => {\r\n  return (\r\n    <button onClick={props.handleClick} className={props.className}>\r\n      <strong>{props.text}</strong>\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default Button;\r\n","import React from \"react\";\r\n\r\nconst SelectField = (props) => {\r\n  return (\r\n    <select\r\n      id={props.id}\r\n      onChange={props.handleAnimationSpeed}\r\n      defaultValue={props.defaultValue}\r\n    >\r\n      <option hidden disabled value={props.defaultValue}>\r\n        {props.defaultValue}\r\n      </option>\r\n      {props.options.map((option, optionID) => {\r\n        return (\r\n          <option key={optionID} value={option}>\r\n            {option}\r\n          </option>\r\n        );\r\n      })}\r\n    </select>\r\n  );\r\n};\r\n\r\nexport default SelectField;\r\n","export const astar = (grid, startCell, finishCell) => {\r\n    const openSet = [];     \r\n    const closedSet = [];   \r\n    openSet.push(grid[startCell.row][startCell.col])\r\n    const visitedInOrder = [];\r\n\r\n    while(openSet.length > 0){\r\n        let lowestIndex = 0;\r\n        for(let i = 0; i < openSet.length; i++){\r\n            if(openSet[i].f < openSet[lowestIndex].f){\r\n                lowestIndex = i;\r\n            }\r\n        }\r\n        \r\n        if(openSet[lowestIndex] === finishCell){\r\n            //return path(finishCell);\r\n            return visitedInOrder;\r\n        }\r\n        \r\n        const current = openSet[lowestIndex]\r\n        visitedInOrder.push(current)\r\n\r\n        removeFromArray(openSet,current) //spllice(lowestIndex,1) ??\r\n        closedSet.push(current)\r\n        //grid[current.row][current.col].isVisited = true;\r\n\r\n        const neighbors = getNeighbors(current,grid);\r\n        for(let i = 0; i < neighbors.length; i++){\r\n            let neighbor = neighbors[i];\r\n            if(neighbor.isWall){\r\n                closedSet.push(neighbor)\r\n                continue;\r\n            }\r\n            visitedInOrder.push(neighbor)\r\n            if(!closedSet.includes(neighbor)){\r\n                //grid[neighbor.row][neighbor.col].g = grid[current.row][current.col].g + 1\r\n                let tempG = grid[current.row][current.col].g + 1\r\n                if(openSet.includes(neighbor)){\r\n                    if(tempG < neighbor.g){\r\n                        neighbor.g = tempG;\r\n                    }\r\n                }else{\r\n                    neighbor.g = tempG;\r\n                    openSet.push(neighbor);\r\n                }\r\n\r\n                neighbor.h = heuristic(neighbor,finishCell)\r\n                neighbor.f = neighbor.g + neighbor.h\r\n                neighbor.previousCell = current;\r\n            }\r\n            \r\n        }\r\n    }\r\n    return visitedInOrder;\r\n    //return grid;\r\n    // const path = [];\r\n    // let end = finishCell\r\n    // while(end.previousCell !== startCell){\r\n    //     path.push(end)\r\n    //     end = end.previousCell\r\n    // }\r\n    // return path;\r\n\r\n\r\n};\r\n\r\n// const path = (endCell) => {\r\n//     const path = [];\r\n//     while(endCell.previousCell != null){\r\n//         path.push(endCell)\r\n//         endCell = endCell.previousCell;\r\n//     }\r\n//     return path;\r\n// }\r\n\r\nconst heuristic = (a,b) => {\r\n    if(a.row === b.row) return Math.abs(a.col-b.col)\r\n    if(a.col === b.col) return Math.abs(a.row-b.row)\r\n    return Math.abs(a.row-b.row) + Math.abs(a.col-b.col)\r\n    //pythagoras a^2 + b^2 = c^2\r\n    //return Math.sqrt(Math.abs(a.col-b.col)+Math.abs(a.row-b.row))\r\n}\r\n  \r\nconst removeFromArray = (arr,element) => {\r\n    for(let i = arr.length-1; i >=0; i--){\r\n        if(arr[i]===element){\r\n            arr.splice(i,1);\r\n        }\r\n    }\r\n}\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n    const numCol = grid[0].length;\r\n    const numRow = grid.length;\r\n    const neighbors = [];\r\n    const { col, row } = cell;\r\n  \r\n    if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n    if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n    if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n    if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n  \r\n    return neighbors;\r\n  };\r\n  ","export const dijkstra = (grid, startCell, finishCell) => {\r\n  const visitedCellsInOrder = [];\r\n  startCell.distance = 0;\r\n  const unVisitedCells = getCells(grid);\r\n  while (unVisitedCells.length) {\r\n    unVisitedCells.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); // min heap better option\r\n    const closestCell = unVisitedCells.shift();\r\n    if (closestCell.distance === Infinity) return visitedCellsInOrder;\r\n    closestCell.isVisited = true;\r\n    visitedCellsInOrder.push(closestCell);\r\n    if (closestCell === finishCell) return visitedCellsInOrder;\r\n    updateUnvisitedNeighbors(closestCell, grid);\r\n  }\r\n};\r\n\r\nconst updateUnvisitedNeighbors = (cell, grid) => {\r\n  const unvisitedNeighbors = getNeighbors(cell, grid).filter(\r\n    (neighbor) => !neighbor.isVisited\r\n  );\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = cell.distance + 1;\r\n    neighbor.previousCell = cell;\r\n  }\r\n};\r\n\r\nconst getNeighbors = (cell, grid) => {\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n  const neighbors = [];\r\n  const { col, row } = cell;\r\n\r\n  if (col - 1 >= 0) neighbors.push(grid[row][col - 1]); //left\r\n  if (col + 1 < numCol) neighbors.push(grid[row][col + 1]); //right\r\n  if (row + 1 < numRow) neighbors.push(grid[row + 1][col]); //top\r\n  if (row - 1 >= 0) neighbors.push(grid[row - 1][col]); //bottom\r\n\r\n  return neighbors;\r\n};\r\n\r\nconst getCells = (grid) => {\r\n  const listOfCells = [];\r\n  const numCol = grid[0].length;\r\n  const numRow = grid.length;\r\n\r\n  for (let i = 0; i < numRow; i++) {\r\n    for (let j = 0; j < numCol; j++) {\r\n      if (grid[i][j].isWall) continue;\r\n      listOfCells.push(grid[i][j]);\r\n    }\r\n  }\r\n  return listOfCells;\r\n};\r\n","import React from \"react\";\r\nimport Legend from \"./Legend\";\r\nimport Button from \"./Button\";\r\nimport SelectField from \"./SelectField\";\r\nimport { astar } from \"../algorithms/astar\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport \"./styles/menu.css\";\r\n\r\nconst Menu = (props) => {\r\n  const options = [\"Fast\", \"Average\", \"Slow\"];\r\n  const solve = props.actions[\"solveFunction\"];\r\n  return (\r\n    <section className=\"menu\">\r\n      <Legend />\r\n      <section className=\"clickable\">\r\n        <section className=\"algorithmsButtons\">\r\n          <Button text={\"Dijkstra\"} handleClick={() => solve(dijkstra)} />\r\n          <Button text={\"A*\"} handleClick={() => solve(astar)} />\r\n          <Button text={\"Generate Maze\"} handleClick={props.actions.genMaze} />\r\n        </section>\r\n        <section className=\"interactions\">\r\n          <SelectField\r\n            id={\"animationSpeed\"}\r\n            options={options}\r\n            defaultValue={\"Speed\"}\r\n            handleAnimationSpeed={props.actions[\"changeSpeedHandler\"]}\r\n          />\r\n          <Button\r\n            className=\"btn-reset\"\r\n            text={\"Reset\"}\r\n            handleClick={props.actions[\"resetGrid\"]}\r\n          />\r\n          {/* <Button\r\n            className=\"btn-wall\"\r\n            text={\"Add walls\"}\r\n            handleClick={props.actions[\"drawingWallsHandler\"]}\r\n          /> */}\r\n          <Button\r\n            className=\"btn-start\"\r\n            text={\"Change Start\"}\r\n            handleClick={props.actions[\"changeStartHandler\"]}\r\n          />\r\n          <Button\r\n            className=\"btn-finish\"\r\n            text={\"Change End\"}\r\n            handleClick={props.actions[\"changeEndHandler\"]}\r\n          />\r\n        </section>\r\n      </section>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default Menu;\r\n","import React from \"react\";\r\nimport \"./styles/cell.css\";\r\n\r\nconst Cell = (props) => {\r\n  const {\r\n    col,\r\n    row,\r\n    isFinish,\r\n    isStart,\r\n    isWall,\r\n    isPath,\r\n    isVisited,\r\n    clickHandler,\r\n  } = props;\r\n\r\n  let cName = \"cell\";\r\n\r\n  if (isVisited) cName = \"cell visited\";\r\n  if (isPath) cName = \"cell path\";\r\n  if (isFinish) cName = \"cell finish\";\r\n  if (isStart) cName = \"cell start\";\r\n  if (isWall) cName = \"cell wall\";\r\n\r\n  return (\r\n    <div onClick={clickHandler} className={cName} id={`${row}-${col}`}>\r\n      {isStart ? <i className=\"far fa-play-circle\"></i> : null}\r\n      {isFinish ? <i className=\"far fa-times-circle\"></i> : null}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport Cell from \"./Cell\";\r\n\r\nconst Grid = (props) => {\r\n  const {\r\n    //handlePress,\r\n    //handleMouseDown,\r\n    //handleMouseUp,\r\n    changeStartCell,\r\n    changeEndCell,\r\n  } = props.actions;\r\n  const {\r\n    isChangingEnd,\r\n    isChangingStart,\r\n    //isDrawingWalls,\r\n    //isMouseClicked,\r\n  } = props.properties;\r\n  return (\r\n    <section\r\n      className=\"grid\"\r\n      id=\"grid\"\r\n      // onMouseMove={isDrawingWalls && isMouseClicked ? handlePress : null}\r\n      // onMouseDown={isDrawingWalls ? handleMouseDown : null}\r\n      // onMouseUp={isDrawingWalls ? handleMouseUp : null}\r\n      // onClick={\r\n      //   isChangingStart ? changeStartCell : isChangingEnd ? changeEndCell : null\r\n      // }\r\n    >\r\n      {props.grid.map((row, rowId) => {\r\n        return (\r\n          <div key={rowId} className=\"row\">\r\n            {row.map((cell, cellId) => {\r\n              const {\r\n                row,\r\n                col,\r\n                isStart,\r\n                isFinish,\r\n                isWall,\r\n                isVisited,\r\n                isPath,\r\n              } = cell;\r\n              return (\r\n                <Cell\r\n                  key={cellId}\r\n                  row={row}\r\n                  col={col}\r\n                  isStart={isStart}\r\n                  isFinish={isFinish}\r\n                  isWall={isWall}\r\n                  isVisited={isVisited}\r\n                  isPath={isPath}\r\n                  clickHandler={\r\n                    isChangingStart\r\n                      ? changeStartCell\r\n                      : isChangingEnd\r\n                      ? changeEndCell\r\n                      : null\r\n                  }\r\n                ></Cell>\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","// http://www.migapro.com/depth-first-search/\r\n\r\nexport default function DFSmaze(\r\n  startCellCoords,\r\n  endCellCoords,\r\n  numRow,\r\n  numCol,\r\n  grid\r\n) {\r\n  for (let i = 0; i < numRow; i++) {\r\n    for (let j = 0; j < numCol; j++) {\r\n      if (\r\n        (i === startCellCoords.row && j === startCellCoords.col) ||\r\n        (i === endCellCoords.row && j === endCellCoords.col)\r\n      )\r\n        continue;\r\n      grid[i][j].isWall = true;\r\n      grid[i][j].isVisited = false;\r\n      grid[i][j].isPath = false;\r\n    }\r\n  }\r\n\r\n  let c = randomInt(0, numCol - 1);\r\n  while (c % 2 === 0) c = randomInt(0, numCol - 1);\r\n\r\n  let r = randomInt(0, numRow - 1);\r\n  while (r % 2 === 0) r = randomInt(0, numRow - 1);\r\n\r\n  const order = [];\r\n  grid[r][c].isWall = false;\r\n  order.push(grid[r][c]);\r\n\r\n  recursion(r, c, grid, order, numRow, numCol);\r\n  return order;\r\n}\r\n\r\nconst recursion = (r, c, grid, order, numRow, numCol) => {\r\n  const randDirs = generateRandomDirections();\r\n  // Examine each direction\r\n  for (let i = 0; i < randDirs.length; i++) {\r\n    // eslint-disable-next-line default-case\r\n    switch (randDirs[i]) {\r\n      case 1: // Up\r\n        //　Whether 2 cells up is out or not\r\n        if (r - 2 <= 0) continue;\r\n        if (grid[r - 2][c].isWall) {\r\n          grid[r - 2][c].isWall = false;\r\n          grid[r - 1][c].isWall = false;\r\n          order.push(grid[r - 2][c]);\r\n          order.push(grid[r - 1][c]);\r\n          recursion(r - 2, c, grid, order, numRow, numCol);\r\n        }\r\n        break;\r\n      case 2: // Right\r\n        // Whether 2 cells to the right is out or not\r\n        if (c + 2 >= numCol - 1) continue;\r\n        if (grid[r][c + 2].isWall) {\r\n          grid[r][c + 2].isWall = false;\r\n          grid[r][c + 1].isWall = false;\r\n          order.push(grid[r][c + 2]);\r\n          order.push(grid[r][c + 1]);\r\n          recursion(r, c + 2, grid, order, numRow, numCol);\r\n        }\r\n        break;\r\n      case 3: // Down\r\n        // Whether 2 cells down is out or not\r\n        if (r + 2 >= numRow - 1) continue;\r\n        if (grid[r + 2][c].isWall) {\r\n          grid[r + 2][c].isWall = false;\r\n          grid[r + 1][c].isWall = false;\r\n          order.push(grid[r + 2][c]);\r\n          order.push(grid[r + 1][c]);\r\n          recursion(r + 2, c, grid, order, numRow, numCol);\r\n        }\r\n        break;\r\n      case 4: // Left\r\n        // Whether 2 cells to the left is out or not\r\n        if (c - 2 <= 0) continue;\r\n        if (grid[r][c - 2].isWall) {\r\n          grid[r][c - 2].isWall = false;\r\n          grid[r][c - 1].isWall = false;\r\n          order.push(grid[r][c - 2]);\r\n          order.push(grid[r][c - 1]);\r\n          recursion(r, c - 2, grid, order, numRow, numCol);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nconst generateRandomDirections = () => {\r\n  const dirs = [];\r\n  for (let i = 0; i < 4; i++) dirs.push(i + 1);\r\n  return shuffle(dirs);\r\n};\r\n\r\nconst shuffle = (a) => {\r\n  for (let i = a.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [a[i], a[j]] = [a[j], a[i]];\r\n  }\r\n  return a;\r\n};\r\n\r\nfunction randomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n","import React from \"react\";\r\nimport \"./styles/visualiser.css\";\r\nimport \"./styles/mobile/media-queries.css\";\r\nimport Footer from \"./Footer\";\r\nimport Menu from \"./Menu\";\r\nimport Grid from \"./Grid\";\r\nimport DFSmaze from \"../algorithms/DFSmaze\";\r\n\r\nlet numRow = 25;\r\nlet numCol = 51;\r\n\r\nconst delay = (ms) => {\r\n  return new Promise((res) => setTimeout(res, ms));\r\n};\r\n\r\nclass App extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      startCellCoords: {\r\n        row: 12,\r\n        col: 8,\r\n      },\r\n      endCellCoords: {\r\n        row: 12,\r\n        col: 14,\r\n      },\r\n      //isDrawingWalls: false,\r\n      isMouseClicked: false,\r\n      isChangingStart: false,\r\n      isChangingEnd: false,\r\n      animationSpeed: 14,\r\n      isAnimationInProccess: false,\r\n    };\r\n    this.tempGrid = null;\r\n  }\r\n\r\n  makeCell = (row, col) => {\r\n    const { startCellCoords, endCellCoords } = this.state;\r\n    return {\r\n      row: row,\r\n      col: col,\r\n      isStart: row === startCellCoords.row && col === startCellCoords.col,\r\n      isFinish: row === endCellCoords.row && col === endCellCoords.col,\r\n      isWall: false,\r\n      previousCell: null,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isPath: false,\r\n      g: 0,\r\n      f: 0,\r\n      h: 0,\r\n    };\r\n  };\r\n  makeGrid = () => {\r\n    const grid = [];\r\n    if (numCol % 2 === 0) numCol++;\r\n    for (let i = 0; i < numRow; i++) {\r\n      const curCol = [];\r\n      for (let j = 0; j < numCol; j++) {\r\n        curCol.push(this.makeCell(i, j));\r\n      }\r\n      grid.push(curCol);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  resetGrid = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.setState({\r\n      grid: this.makeGrid(),\r\n      isDrawingWalls: false,\r\n      isMouseClicked: false,\r\n      isChangingStart: false,\r\n      isChangingEnd: false,\r\n    });\r\n  };\r\n\r\n  genMaze = async () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const { startCellCoords, endCellCoords } = this.state;\r\n    const grid = this.makeGrid();\r\n    DFSmaze(startCellCoords, endCellCoords, numRow, numCol, grid);\r\n    this.setState({ grid: grid });\r\n    // const walls = [];\r\n    // for (let i = 0; i < numRow; i++) {\r\n    //   for (let j = 0; j < numCol - 1; j++) {\r\n    //     if (grid[i][j].isWall) walls.push(grid[i][j]);\r\n    //   }\r\n    // }\r\n    // const finalGrid = grid;\r\n    // for (let i = 0; i < numRow; i++) {\r\n    //   finalGrid[i].pop();\r\n    // }\r\n    // numCol--;\r\n    // const result = this.animateMaze(walls);\r\n    // result\r\n    //   .then(async (ms) => {\r\n    //     await delay(ms);\r\n    //   })\r\n    //   .then(() => {\r\n    //     this.setState({ grid: finalGrid });\r\n    //   });\r\n  };\r\n\r\n  solve = async (algorithm) => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const { grid, startCellCoords, endCellCoords } = this.state;\r\n    for (let i = 0; i < numCol; i++) {\r\n      for (let j = 0; j < numRow; j++) {\r\n        grid[j][i].isVisited = false;\r\n        grid[j][i].f = 0;\r\n        grid[j][i].g = 0;\r\n        grid[j][i].h = 0;\r\n        grid[j][i].isPath = false;\r\n      }\r\n    }\r\n    await this.setState({\r\n      grid: grid,\r\n      isAnimationInProccess: true,\r\n    });\r\n    const startCell = grid[startCellCoords.row][startCellCoords.col];\r\n    const endCell = grid[endCellCoords.row][endCellCoords.col];\r\n\r\n    const visitedCellsInOrder = algorithm(grid, startCell, endCell);\r\n\r\n    const result = this.animateVisited(visitedCellsInOrder);\r\n    result\r\n      .then(async (data) => {\r\n        await delay(data[1]);\r\n        return data[0];\r\n      })\r\n      .then((grid) => {\r\n        const newGrid = this.animatePath(grid);\r\n        this.setState({ grid: newGrid, isAnimationInProccess: false });\r\n      });\r\n  };\r\n\r\n  //ANIMATIONS\r\n  animateVisited = (visitedCellsInOrder) => {\r\n    const { grid, endCellCoords, startCellCoords, animationSpeed } = this.state;\r\n    return new Promise(function (resolve, reject) {\r\n      for (let i = 1; i < visitedCellsInOrder.length; i++) {\r\n        const row = visitedCellsInOrder[i].row;\r\n        const col = visitedCellsInOrder[i].col;\r\n        if (\r\n          (row === startCellCoords.row && col === startCellCoords.col) ||\r\n          (row === endCellCoords.row && col === endCellCoords.col)\r\n        )\r\n          continue;\r\n        setTimeout(() => {\r\n          grid[row][col].isVisited = true;\r\n          document.getElementById(`${row}-${col}`).className = \"cell visited\";\r\n        }, i * animationSpeed);\r\n      }\r\n      resolve([grid, visitedCellsInOrder.length * animationSpeed]); // immediately give the result: 123\r\n    });\r\n  };\r\n  animatePath = (grid) => {\r\n    const { endCellCoords, startCellCoords, animationSpeed } = this.state;\r\n    const lastCell = grid[endCellCoords.row][endCellCoords.col];\r\n    let temp = lastCell;\r\n\r\n    //shortest path\r\n    const path = [];\r\n    while (temp !== null) {\r\n      path.push(temp);\r\n      temp = temp.previousCell;\r\n    }\r\n\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      let row = path[i].row;\r\n      let col = path[i].col;\r\n      if (\r\n        (row === startCellCoords.row && col === startCellCoords.col) ||\r\n        (row === endCellCoords.row && col === endCellCoords.col)\r\n      )\r\n        continue;\r\n      setTimeout(() => {\r\n        grid[row][col].isPath = true;\r\n        document.getElementById(`${row}-${col}`).className = \"cell path\";\r\n      }, i * animationSpeed);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  // INTERACTIONS HANDLERS\r\n  handleAnimationSpeed = (e) => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const value = e.target.value;\r\n    if (value === \"Fast\") this.setState({ animationSpeed: 9 });\r\n    else if (value === \"Average\") this.setState({ animationSpeed: 14 });\r\n    else if (value === \"Slow\") this.setState({ animationSpeed: 25 });\r\n  };\r\n  changeStartHandler = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.setState({\r\n      isChangingStart: true,\r\n      isChangingEnd: false,\r\n      isDrawingWalls: false,\r\n    });\r\n  };\r\n  changeEndHandler = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.setState({\r\n      isChangingEnd: true,\r\n      isChangingStart: false,\r\n      isDrawingWalls: false,\r\n    });\r\n  };\r\n  changeEndCell = (e) => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { endCellCoords, grid } = this.state;\r\n    grid[endCellCoords.row][endCellCoords.col].isFinish = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isFinish = true;\r\n    this.setState({\r\n      grid: grid,\r\n      endCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n  changeStartCell = (e) => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const cellCoords = e.target.id.split(\"-\");\r\n    if (cellCoords.length < 2) return;\r\n\r\n    const { startCellCoords, grid } = this.state;\r\n    grid[startCellCoords.row][startCellCoords.col].isStart = false;\r\n    grid[cellCoords[0]][cellCoords[1]].isStart = true;\r\n    this.setState({\r\n      grid: grid,\r\n      startCellCoords: {\r\n        row: parseInt(cellCoords[0]),\r\n        col: parseInt(cellCoords[1]),\r\n      },\r\n    });\r\n  };\r\n\r\n  //window sizing/resizing for responsive grid\r\n  sizing = async () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const width = window.innerWidth;\r\n\r\n    if (width <= 576) numCol = 15;\r\n    else if (width > 576 && width <= 1024) numCol = 25;\r\n    else if (width > 1024 && width < 1200) numCol = 30;\r\n    else numCol = 50;\r\n\r\n    await this.setState({\r\n      startCellCoords: { row: 12, col: Math.ceil(numCol / 3) },\r\n      endCellCoords: { row: 12, col: Math.ceil(numCol / 3) * 2 },\r\n    });\r\n\r\n    const grid = this.makeGrid();\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  };\r\n  reSizing = async () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const width = window.innerWidth;\r\n\r\n    if (width <= 576) numCol = 15;\r\n    else if (width > 576 && width <= 1024) numCol = 25;\r\n    else if (width > 1024 && width < 1200) numCol = 30;\r\n    else numCol = 50;\r\n\r\n    await this.setState({\r\n      startCellCoords: {\r\n        row: 12,\r\n        col: Math.ceil(numCol / 3),\r\n      },\r\n      endCellCoords: {\r\n        row: 12,\r\n        col: Math.ceil(numCol / 3) * 2,\r\n      },\r\n    });\r\n\r\n    const grid = this.makeGrid();\r\n\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  };\r\n\r\n  componentDidMount() {\r\n    window.onload = this.sizing;\r\n    window.addEventListener(\"resize\", this.reSizing);\r\n  }\r\n\r\n  render() {\r\n    const grid = this.state.grid;\r\n    const buttonActions = {\r\n      genMaze: this.genMaze,\r\n      solveFunction: this.solve,\r\n      resetGrid: this.resetGrid,\r\n      drawingWallsHandler: this.drawingWallsHandler,\r\n      changeStartHandler: this.changeStartHandler,\r\n      changeEndHandler: this.changeEndHandler,\r\n      changeSpeedHandler: this.handleAnimationSpeed,\r\n    };\r\n    const gridProperties = {\r\n      isDrawingWalls: this.state.isDrawingWalls,\r\n      isMouseClicked: this.state.isMouseClicked,\r\n      isChangingStart: this.state.isChangingStart,\r\n      isChangingEnd: this.state.isChangingEnd,\r\n    };\r\n    const gridActions = {\r\n      handlePress: this.handlePress,\r\n      handleMouseDown: this.handleMouseDown,\r\n      handleMouseUp: this.handleMouseUp,\r\n      changeEndCell: this.changeEndCell,\r\n      changeStartCell: this.changeStartCell,\r\n    };\r\n    return (\r\n      <main>\r\n        <Menu actions={buttonActions} />\r\n        <Grid grid={grid} actions={gridActions} properties={gridProperties} />\r\n        <Footer />\r\n      </main>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n\r\n//bin (maybe will use in future)\r\n/*  handlePress = (e) => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    const coords = e.target.id.split(\"-\");\r\n    if (coords.length !== 2) {\r\n      console.log(\"out\");\r\n      this.handleMouseUp();\r\n      return;\r\n    }\r\n    if (\r\n      (parseInt(coords[0]) === this.state.startCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.startCellCoords.col) ||\r\n      (parseInt(coords[0]) === this.state.endCellCoords.row &&\r\n        parseInt(coords[1]) === this.state.endCellCoords.col)\r\n    )\r\n      return;\r\n    document.getElementById(`${coords[0]}-${coords[1]}`).className =\r\n      \"cell wall\";\r\n    this.tempGrid[coords[0]][coords[1]].isWall = true;\r\n    this.tempGrid[coords[0]][coords[1]].isVisited = false;\r\n    this.tempGrid[coords[0]][coords[1]].isPath = false;\r\n  };\r\n  handleMouseDown = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.tempGrid = this.state.grid;\r\n    this.setState({\r\n      isMouseClicked: true,\r\n    });\r\n  };\r\n  handleMouseUp = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.setState({\r\n      isMouseClicked: false,\r\n      grid: this.tempGrid,\r\n    });\r\n    this.tempGrid = null;\r\n  };\r\n  drawingWallsHandler = () => {\r\n    if (this.state.isAnimationInProccess) return;\r\n    this.setState({\r\n      isDrawingWalls: true,\r\n      isChangingStart: false,\r\n      isChangingEnd: false,\r\n    });\r\n  };\r\n    animateMaze = (walls) => {\r\n    const { grid, endCellCoords, startCellCoords, animationSpeed } = this.state;\r\n    return new Promise(function (resolve, reject) {\r\n      for (let i = 0; i < walls.length; i++) {\r\n        const row = walls[i].row;\r\n        const col = walls[i].col;\r\n        if (\r\n          (row === startCellCoords.row && col === startCellCoords.col) ||\r\n          (row === endCellCoords.row && col === endCellCoords.col)\r\n        )\r\n          continue;\r\n        setTimeout(() => {\r\n          //grid[row][col].isWall = true;\r\n          document.getElementById(`${row}-${col}`).className = \"cell wall\";\r\n        }, i * animationSpeed);\r\n      }\r\n      resolve(walls.length * animationSpeed); // immediately give the result: 123\r\n    });\r\n  };\r\n*/\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./visualiser/components/App\";\n// import \"./visualiser/components/styles/visualiser.less\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}